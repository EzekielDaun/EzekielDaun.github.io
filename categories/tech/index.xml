<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Tech - Category - Ez&#39;s blog</title>
        <link>https://ezekieldaun.github.io/categories/tech/</link>
        <description>Tech - Category - Ez&#39;s blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 28 Dec 2021 15:34:52 -0800</lastBuildDate><atom:link href="https://ezekieldaun.github.io/categories/tech/" rel="self" type="application/rss+xml" /><item>
    <title>Balancing Bot</title>
    <link>https://ezekieldaun.github.io/balancing-bot/</link>
    <pubDate>Tue, 28 Dec 2021 15:34:52 -0800</pubDate>
    <author>xxxx</author>
    <guid>https://ezekieldaun.github.io/balancing-bot/</guid>
    <description><![CDATA[<p>In this post, I am going to share my experience in developing a balancing bot. As I haven&rsquo;t formally learned any courses about the control system, I could not guarantee the correctness of all the points.</p>
<h2 id="the-cascade-pid-controller-for-the-bot">The Cascade PID Controller for the Bot</h2>
<h3 id="pid">PID</h3>
<p>There are too much explanation about the PID <a href="https://en.wikipedia.org/wiki/PID_controller" target="_blank" rel="noopener noreffer ">controller</a>. So I will just share my own understanding.</p>
<p>You must have tried to play a song with a steel ruler, watching it vibrate, become weaker and weaker and finally stop. The ruler can vibrate because it has some elasticity, while this vibration becomes weaker and weaker since there is some sort of damping. A spring with a damper could solve most problems, and this is actually what a PD controller does. The second-order ODEs could explain:</p>]]></description>
</item>
<item>
    <title>A First Step in STM32 Embedded Rust</title>
    <link>https://ezekieldaun.github.io/hello-embedded-rust/</link>
    <pubDate>Mon, 27 Dec 2021 18:48:13 -0800</pubDate>
    <author>xxxx</author>
    <guid>https://ezekieldaun.github.io/hello-embedded-rust/</guid>
    <description><![CDATA[<p>A brief summary for recent learning about embedded rust in internship and projects.</p>
<h2 id="resources">Resources</h2>
<ul>
<li><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener noreffer ">The Book</a>: Basic rust grammar. Pay attention to <code>Channel</code>, <code>Mutex</code>, <code>Cell</code>, <code>RefCell</code> etc. in the concurrency section, which are also useful in embedded rust.</li>
<li><a href="https://docs.rust-embedded.org/discovery/" target="_blank" rel="noopener noreffer ">Discovery</a>: There is a <a href="https://docs.rust-embedded.org/discovery/microbit/" target="_blank" rel="noopener noreffer ">new version</a> using micro:bit when I write this blog. I was reading the <a href="https://docs.rust-embedded.org/discovery/f3discovery/" target="_blank" rel="noopener noreffer ">STM32F3Discovery</a> version.</li>
<li><a href="https://docs.rust-embedded.org/book/" target="_blank" rel="noopener noreffer ">The Embedded Rust Book</a>: If you are experienced in embedded systems, you can jump right in to this book. I have the F3 board so I didn&rsquo;t use QEMU.</li>
<li><a href="https://rtic.rs" target="_blank" rel="noopener noreffer ">RTIC</a>: A concurrent framework on bare metal. Better handle rust variables with ownerships. When I learned it was v0.5. Good to see that 1.0 has been released.</li>
<li><a href="https://ferrous-systems.com/blog/all/" target="_blank" rel="noopener noreffer ">ferrous-systems&rsquo; blog</a>: This company introduced many technologies into embedded rust, includes testing, debugging etc. The most impressive is that they implement a <a href="https://github.com/ferrous-systems/async-on-embedded" target="_blank" rel="noopener noreffer ">async/await executor</a>.</li>
</ul>
<h2 id="environment">Environment</h2>
<h3 id="rust-toolchain">Rust Toolchain</h3>
<p>Here I installed the nightly version of msvc toolchain using rustup.</p>]]></description>
</item>
</channel>
</rss>
