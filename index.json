[{"categories":["tech"],"content":"In this post, I am going to share my experience in developing a balancing bot. As I haven’t formally learned any courses about the control system, I could not guarantee the correctness of all the points. ","date":"2021-12-28","objectID":"/balancing-bot/:0:0","tags":null,"title":"Balancing Bot","uri":"/balancing-bot/"},{"categories":["tech"],"content":"The Cascade PID Controller for the Bot ","date":"2021-12-28","objectID":"/balancing-bot/:1:0","tags":null,"title":"Balancing Bot","uri":"/balancing-bot/"},{"categories":["tech"],"content":"PID There are too much explanation about the PID controller. So I will just share my own understanding. You must have tried to play a song with a steel ruler, watching it vibrate, become weaker and weaker and finally stop. The ruler can vibrate because it has some elasticity, while this vibration becomes weaker and weaker since there is some sort of damping. A spring with a damper could solve most problems, and this is actually what a PD controller does. The second-order ODEs could explain: $$ my’’+cy’+ky=f(t) $$ Assume that $m, c, k$ are all positive. The solutions of the characteristic equation $r_1 , r_2$ have a real negative part $\\frac{-c}{2m}$. So the general solution of the ODE $y=K_1 e^{r_1 t} + K_2 e^{r_2 t}$ must converge. The ideal case is the critical damping, where $r_1 = r_2$ and the general solution becomes $y=Ke^{rt} + Kte^{rt}$. Therefore, a PD controller could be considered as adding a spring and a damper to the system to make it stable. However, with some constant external load, the controlled value will eventually stabilize at some deviation from the target, depending on the P parameter. The integration part I is introduced to cancel this kind of steady-state error. ","date":"2021-12-28","objectID":"/balancing-bot/:1:1","tags":null,"title":"Balancing Bot","uri":"/balancing-bot/"},{"categories":["tech"],"content":"The Angle Loop Take the bot’s angle as the input of the PD controller. When the bot inclines, we accelerate the base to catch up the head, and vice versa. However, with only the angle loop, even if well-tuned, the bot could eventually accelerate in one direction, because the motor has a maximum speed. When the bot is perpendicular to the ground, it doesn’t mean that the bot has no speed. Because of the small P output, the motor behaves like a brake, making the robot rapidly nods to the ground, resulting in an even larger angle than before. ","date":"2021-12-28","objectID":"/balancing-bot/:1:2","tags":null,"title":"Balancing Bot","uri":"/balancing-bot/"},{"categories":["tech"],"content":"The Speed Loop To solve this problem, the speed loop is introduced. It takes the speed of the robot as input, outputs to the angle loop as the zero angle. When the robot has a positive speed, it makes the angle loop’s zero angle decline, thus, generate a negative output to cancel this positive speed. The angle loop uses PD, and the speed loop use PI, since we are not interesting in the changing rate of speed. The tuning of two controllers could be a little harder. It’s obvious that we need to tune the angle loop first because it directly controls the actuator. The ideal process is tuning the angle loop’s P parameter first for a fast response, and then the angle loop’s D parameter until the bot could stand for a while, finally the speed loop. ","date":"2021-12-28","objectID":"/balancing-bot/:1:3","tags":null,"title":"Balancing Bot","uri":"/balancing-bot/"},{"categories":["tech"],"content":"The Story from Interrupt ","date":"2021-12-28","objectID":"/balancing-bot/:2:0","tags":null,"title":"Balancing Bot","uri":"/balancing-bot/"},{"categories":["tech"],"content":"RaspberryPi I always think that Arduino is more like a toy, because of the lack of useful applications. But RPi, which has GPIO ports too, is also a more playable Linux PC! So I bought the cheapest RPi model 4B with 2 GB RAM to make this bot. I mainly use the C language and Wiring Pi. The other hardware and kits are from taobao. As a mechanical engineering student, I drew a acrylic board to position them. They were connected by jumping wires and a breadboard. Alright, let’s drive them first: DC Motor The driver is the common L298N. In brief we use 2 pins for direction, and an extra PWM pin for the output voltage. It’s very easy to use WiringPi’s hardware PWM function to drive RPi’s pwm0 and pwm1. MPU6050 A six-DoF accelerometer and gyroscope, with integrated DMPDigital Motion Processor that can output the fused orientation in quaternion, saving the load on MCU. However, it could not be used with common I2C instructions described in the manual. An official embedded motion driver provides the code for using DMP on MSP430. The core is passing a bunch of mysterious numbers through I2C to turn on the DMP function. I spent a lot of time looking for a RPi’s DMP library and only got this library in C++. Although it’s possible to port the motion driver to RPi, this might be too hard for me, a newbie at that time. Anyway, let’s write some C in C++. Encoder It generates two square waves with 90° phase latency, with a fixed number of rising/falling edges in each round. When there is an edge in one wave, by reading the voltage level of the other wave, the direction could be determined. Magic! It often works with interrupts on RPi. WiringPi wraps up convenient functions to register interrupt handlers: int wiringPiISR (int pin, int edgeType, void (*function)(void)) ; Pass in the function pointer, the registered function could then be called when the interrupt occurs. Notice that this function pointer takes void and returns void. How could it communicate to other codes? The answer is global variable: long long COUNT; void myISR(void); void myISR(void){ COUNT++; } int main(void){ wiringPiSetup(); /* Some code */ wiringPiISR(pin, INT_EDGE_BOTH, myISR); /* Some code */ } Therefore, when the interrupt occurs, COUNT would increment. Since the encoder counts very fast, I declared the type of COUNT as long long (64 Bits on RPi). No!!!! Here we go. I successfully drive the motor and encoder!Actually? And we can elegantly press q in SSH to quit. Everything goes well and there is only the control part to do. I’ll put my C code at this stage: motor.h #include \u003cpthread.h\u003e#include \u003cstdbool.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003cwiringPi.h\u003e #define PIN_MOTOR1 26 #define PIN_MOTOR1_IN1 6 #define PIN_MOTOR1_IN2 27 #define PIN_MOTOR1_OUT1 28 #define PIN_MOTOR1_OUT2 29 #define PIN_MOTOR2 23 #define PIN_MOTOR2_IN1 22 #define PIN_MOTOR2_IN2 21 #define PIN_MOTOR2_OUT1 24 #define PIN_MOTOR2_OUT2 25 #define START_POWER 120 typedef struct smotor { const short PIN; const short PIN_IN1; const short PIN_IN2; const short PIN_OUT1; const short PIN_OUT2; const short DIR; const void (*run)(); const int (*readSpd)(); long long lastPos; } Motor; int motorInit(void); static void motor(Motor *pmotor, int power); static int readSpd(Motor *); static void readEnc1A(void); static void readEnc1B(void); static void readEnc2A(void); static void readEnc2B(void); Motor leftWheel; Motor rightWheel; motor.c #include \"motor.h\" int motorInit(void) { if (!wiringPiSetup()) { /* set interrupt response */ wiringPiISR(PIN_MOTOR1_OUT1, INT_EDGE_BOTH, \u0026readEnc1A); wiringPiISR(PIN_MOTOR1_OUT2, INT_EDGE_BOTH, \u0026readEnc1B); wiringPiISR(PIN_MOTOR2_OUT1, INT_EDGE_BOTH, \u0026readEnc2A); wiringPiISR(PIN_MOTOR2_OUT2, INT_EDGE_BOTH, \u0026readEnc2B); /* set pin mode */ pinMode(PIN_MOTOR1, PWM_OUTPUT); pinMode(PIN_MOTOR1_IN1, OUTPUT); pinMode(PIN_MOTOR1_IN2, OUTPUT); pinMode(PIN_MOTOR1_OUT1, INPUT); pinMode(PIN_MOTOR1_OUT2, INPUT); pinMode(PIN_MOTOR2, PWM_OUTPUT); pinMode(PIN_MOTOR2_IN1, OUTPUT); pinMode(","date":"2021-12-28","objectID":"/balancing-bot/:2:1","tags":null,"title":"Balancing Bot","uri":"/balancing-bot/"},{"categories":["tech"],"content":"Rust and Concurrent Programming My short winter break came to an end, and I failed in my first trial to make this bot. Later, in my free time besides online courses, I coincidentally met the Rust programming language. I felt good having a quick glance at the book and spent about three weeks thoroughly reading it. Its special Ownership and Borrow Checker impressed me very much. They define: At any given time, you can have either one mutable reference or any number of immutable references. References must always be valid. The second point is easy to understand. In C/C++, never use a freed pointer. But the first one… Wait, how did I implement my speed measuring thread? Let’s give an end to this problem: race condition. My Raspbian is a 32-bit version, where a long long int is a 64-bit signed integer. In other words, almost all operations towards it could not be completed in a single assembly instruction. Therefore, when the speed measuring thread partly change the counter but not complete yet, it might be preempted by the scheduler to the main thread. Now reading(loading) this counter in main could generate a race condition. The reason that the C version worked is that it only prints the counter without spawning another thread. The IRQ handler runs really fast and could never be preempted by other threads, while the interrupt frequency isn’t that high to frequently preempt the reading process in the main thread. When I check the makefiles, I found the C version was compiled with -O3 while the C++ version had no optimization option at all So, what are the proper ways to do that? Atomic Operations An atomic operation will never be preempted. The bad thing is that it depends on your CPU instruction set and the compiler, and usually, it can only operate data type no longer than the CPU’s word size. For Ordering, if we only need it to be atomic (usually in single-thread application) without considering the memory consistency, just choose Ordering::Relax, which is also the best choice for a counter. In multi-thread models, you first need to understand your memory model, then choose the ordering. Usually the most strict is Ordering::SeqCst. Mutex\\RwLock (for normal threads\\tasks) For sharing resources between multiple threads with an OS/RTOS, these two locks are recommended. See details in the book. Once failed in pending the lock, the thread could give up their time slice back to the scheduler for other threads. Critical Section(IRQ Handler) Since interrupts can always preempt the running thread unless you allow an IRQ handler to check the resource’s availability first and not to handle when the resource is occupied, the above locks in normal threads will not actually work. Some CPUs could temporarily disable all the interrupts, so that the running thread would not be preempted. If using Rust, Mutex, RefCell etc. are needed to pass compiling, see the embedded rust book. Buffer Another clever way is to use the memory to communicate. A probable implementation for a ring buffer could have an array and head\u0026tail pointers. We could let the tx to have the ownership of the head, rx to have the tail. Increment the corresponding pointer after each operation. As long as the array is long enough and the the rx could handle faster than tx in average, we won’t miss any messages. If I were to redesign the speed measuring login in RPi, I would use an AtomicI32 in IRQ for the encoder counter, a RwLock\u003cRefCell\u003c_\u003e\u003e for the speed global variable. To make no race conditions. However, in my later internship, I learned STM32, a common model is F103C8T6@72MHz, which is definitely enough for a balancing bot. Compared with the RPi4B, which requires a 5V3A power supply and I deliberately bought a battery extension board for it, making it super bulky. The STM32 has a QEIQuadrature Encoder Interface option in Timer peripherals that allows us to read the speed by a timer interrupt invoked “read and reset” operation. However when I implemented this in Rust, I spent","date":"2021-12-28","objectID":"/balancing-bot/:2:2","tags":null,"title":"Balancing Bot","uri":"/balancing-bot/"},{"categories":["tech"],"content":"Sensor Fusion Remember the DMP in MPU6050? Since I didn’t found a workable DMP library (called crate in Rust) in Rust, I used the raw data from the sensor. To get the angle, just simply compare the direction of the acceleration with gravity. The MPU6050 crate has already implemented this function get_acc_angles(\u0026mut self) -\u003e Result\u003cVector2, Mpu6050Error\u003e. Combined with the PID crate with the angle data as P input, gyro data as D input, I got my code compiled in less than an hour. I have to praise Rust that in 99% cases, a code passed compiling could directly run without critical bugs. I tilted the bot and it responded well as expected, which prove that the polarities of each parameter are all correct. But I struggled in tuning for three days without any progress… Even the most basic position loop works really bad. The best I tried could merely stand for around 10s. I tried to fix the wheels to make it a simply reversed pendulum and see what would happen. WTF!? It failed to be stable as well…There must be some critical problems… I logged all the data and found the calculated angle a very noisy signal. But it was still unstable even I manually smoothed it… Well, I have to admit that it actually make sense. Because the bot is moving, there have to be an additional acceleration adding to the gravity, which makes the calculated angle unreliable. So how to get the angle? Here are some answers: ","date":"2021-12-28","objectID":"/balancing-bot/:3:0","tags":null,"title":"Balancing Bot","uri":"/balancing-bot/"},{"categories":["tech"],"content":"Complementary Filter $$ \\theta = k \\cdot \\theta_{\\text{acc}} + (1-k)\\cdot \\int{{\\omega}dt} $$ By integrating the angular speed reading $\\omega$, we could get another angle measurement $\\theta_\\text{gyro}$. Of course this angle should have some error caused by the integrating implementation. The angle measured by comparing acceleration with gravity is notated as $\\theta_\\text{acc}$. We can assign different weights to both values, take the weighted sum as the result. Actual implementation could use recursion: $$ \\theta_{i+1} = k \\cdot \\theta_{\\text{acc}} + (1-k)\\cdot ({\\theta_{i} + \\omega dt}) $$ We can also dynamically adjust the weight. For example, when the accelerometer has a large reading, the gyro should be more reliable; when the gyro has a small reading, the accelerometer should be more reliable. At first, I was planning to use Rust on STM32 to implement a complementary filter. Because as mentioned before, I had run up all the timers and had to use delay in the main loop, the practice showed that the actual delay time would vary, which made it hard to decide the $dt$ to be multiplied. I don’t want this project to be even harder, so finally I decided to return to C, with off-the-shelf DMP driver on STM32. ","date":"2021-12-28","objectID":"/balancing-bot/:3:1","tags":null,"title":"Balancing Bot","uri":"/balancing-bot/"},{"categories":["tech"],"content":"Kalman Filter The most famous filter in the control theorem. However, I was not able to understand it at this time. I tried the existing rust crate adskalman but failed because the binaries are too large to flash. I wish sometime in future I could complete this section. ","date":"2021-12-28","objectID":"/balancing-bot/:3:2","tags":null,"title":"Balancing Bot","uri":"/balancing-bot/"},{"categories":["tech"],"content":"Summary The final bot with C and DMP is shown in the following picture. I’m not going to put the final code as it was done in limited time with very bad quality. It wouldn’t be hard to build a balancing bot as long as you understand the theory behind it. Actually, the most time-spending part was dealing with hardware and learning concurrent programming with a non-linear control flow. If I had chosen Arduino first, with tons of online Arduino resources, I may not meet Rust and STM32. Looking back on this long journey from RPi, I sincerely appreciate myself for getting these interesting experiences and knowledge. ","date":"2021-12-28","objectID":"/balancing-bot/:4:0","tags":null,"title":"Balancing Bot","uri":"/balancing-bot/"},{"categories":["tech"],"content":"A brief summary for recent learning about embedded rust in internship and projects. ","date":"2021-12-27","objectID":"/hello-embedded-rust/:0:0","tags":null,"title":"A First Step in STM32 Embedded Rust","uri":"/hello-embedded-rust/"},{"categories":["tech"],"content":"Resources The Book: Basic rust grammar. Pay attention to Channel, Mutex, Cell, RefCell etc. in the concurrency section, which are also useful in embedded rust. Discovery: There is a new version using micro:bit when I write this blog. I was reading the STM32F3Discovery version. The Embedded Rust Book: If you are experienced in embedded systems, you can jump right in to this book. I have the F3 board so I didn’t use QEMU. RTIC: A concurrent framework on bare metal. Better handle rust variables with ownerships. When I learned it was v0.5. Good to see that 1.0 has been released. ferrous-systems’ blog: This company introduced many technologies into embedded rust, includes testing, debugging etc. The most impressive is that they implement a async/await executor. ","date":"2021-12-27","objectID":"/hello-embedded-rust/:1:0","tags":null,"title":"A First Step in STM32 Embedded Rust","uri":"/hello-embedded-rust/"},{"categories":["tech"],"content":"Environment ","date":"2021-12-27","objectID":"/hello-embedded-rust/:2:0","tags":null,"title":"A First Step in STM32 Embedded Rust","uri":"/hello-embedded-rust/"},{"categories":["tech"],"content":"Rust Toolchain Here I installed the nightly version of msvc toolchain using rustup. Download core for different target platforms. Otherwise would be unable to compile: rustup target add thumbv6m-none-eabi # Cortex-M0 and Cortex-M0+ rustup target add thumbv7m-none-eabi # Cortex-M3 rustup target add thumbv7em-none-eabi # Cortex-M4 and Cortex-M7 (no FPU) rustup target add thumbv7em-none-eabihf # Cortex-M4F and Cortex-M7F (with FPU) ","date":"2021-12-27","objectID":"/hello-embedded-rust/:2:1","tags":null,"title":"A First Step in STM32 Embedded Rust","uri":"/hello-embedded-rust/"},{"categories":["tech"],"content":"Debugging Tools I am using the scoop package manager. So just scoop install the following tools: arm-none-eabi-gdb openocd Besides, if using ST-LINK, manually install the driver. This link (Chinese) integrated debugging tools into vscode. Haven’t tried since CLI is enough. ","date":"2021-12-27","objectID":"/hello-embedded-rust/:2:2","tags":null,"title":"A First Step in STM32 Embedded Rust","uri":"/hello-embedded-rust/"},{"categories":["tech"],"content":"Hello World cortex-m only. Other platforms untested. cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart modify .cargo/config.toml modify memory.x. Usualy STM32 has the FLASH address on 0x08000000, RAM address on 0x20000000. If you see multiple RAMs in the manual, take the first one’s size. modify openocd.cfg, available configuring scripts could be found under openocd’s root directory run openocd at your project directory, keep this terminal open open a new terminal window, cargo run, see if there’s any output ","date":"2021-12-27","objectID":"/hello-embedded-rust/:3:0","tags":null,"title":"A First Step in STM32 Embedded Rust","uri":"/hello-embedded-rust/"},{"categories":["tech"],"content":"PAC \u0026 HAL PACPeripheral Access Crate is usually generated automatically by svd2rust, according to the SVDCMSIS System View Description file from suppliers, wraps basic operation on registers. The API is like: pwm.ctl.modify(|r,w|w.globalsync0().clear_bit()); HALHardware Abstract Layer is based on the PAC, (partly) implements embedded-hal. The STM32 series have some different implementations among each other, making the code for the same peripheral usually not interchangeable. You may not use all the driver crates since it requires some traits that the HAL doesn’t implement, or you have to use unsafe blocks to directly manipulate registers. ","date":"2021-12-27","objectID":"/hello-embedded-rust/:4:0","tags":null,"title":"A First Step in STM32 Embedded Rust","uri":"/hello-embedded-rust/"},{"categories":["tech"],"content":"To Start with (Bare Metal) #![no_main]/* use entry macro */#![no_std]/* std not available */usepanic_semihostingas_;/* choose panic handler, need a debugger or it would block */// use panic_halt as _; // use panic_abort as _; /* need nightly toolchain */ // use cortex_m::asm; /* if need to use assembly */ usecortex_m_rt::entry;// use cortex_m_semihosting::hprintln; /* println! with semihosting, makes debugging easier */ // use core::fmt::Write; /* if instead using serial port, use write! to write into serial's tx */ usehal::{delay::Delay,/* delay function */pac,prelude::*,};usestm32f1xx_halashal;/* import a hal */#[entry]fn main()-\u003e !{let(dp,cp)=(/* dp: device peripherals that the MCU designer provided */pac::Peripherals::take().unwrap(),/* cp: core peripherals that comes with ARM core */cortex_m::Peripherals::take().unwrap(),);/* Setup the clock tree */let(mutflash,mutrcc)=(dp.FLASH.constrain(),dp.RCC.constrain());letclocks=rcc.cfgr.use_hse(8.mhz()).freeze(\u0026mutflash.acr);/* Use SYST or other clock sources to initialize the delay object */letmutdelay=Delay::new(cp.SYST,clocks);/* gpio abstraction, depends on the hal */let(mutgpioa,mutgpiob)=(dp.GPIOA.split(\u0026mutrcc.apb2),dp.GPIOB.split(\u0026mutrcc.apb2));loop{/* do something */}}``` ","date":"2021-12-27","objectID":"/hello-embedded-rust/:5:0","tags":null,"title":"A First Step in STM32 Embedded Rust","uri":"/hello-embedded-rust/"},{"categories":["tech"],"content":"Safe Global Variables We all know that modifying a static mut variable is unsafe in rust. Tons of style guides require for less global variables as possible. However, they are commonly used in embedded systems as we are doing low level coding and the whole program is not that complex. A better way in rust is using RTIC. But here we start from the basics. Atomic is the best way if the platform supports atomic operations. Simple and safe. Disadvantages are that there cannot be complex logic, and only a few primitive types are supported. Mutex\u003cRefCell\u003cT\u003e\u003e with critical section. Need to use cortex_m::interrupt::{self, Mutex};. Can wrap up complex data types, including abstract for peripherals. But it makes a lot of noise in your code. The usageis roughly: declare a static FOO:Mutex\u003cRefCell\u003cOption\u003cT\u003e\u003e\u003e = Mutex::new(RefCell::new(None)); initialize peripherals in the start of your main() and then open a critical section interrupt::free(|cs| FOO.borrow(cs).replace(Some(T)));, move the ownership to the global variable FOO to use in other places, after entering a critical section, use FOO.borrow(cs).borrow() to get the inner RefCell then as_ref() to get the wrapped T I nearly never use this way as it’s too complex and mentally exhausting. In a large project just use RTIC. This part usually makes me mad, as you have to use a bunch of layers to wrap up things that you could directly write in C, even if I know that there shouldn’t be any problem. ","date":"2021-12-27","objectID":"/hello-embedded-rust/:6:0","tags":null,"title":"A First Step in STM32 Embedded Rust","uri":"/hello-embedded-rust/"},{"categories":["tech"],"content":"RTIC I really want to call RTIC a preemptive scheduler. If together with a memory allocator, it works just like a preemptive RTOS. However it’s just a foreground/background system, managing tasks by setting interrupt priorities, without a context switching function. The reason we choose it is that it wraps up the complex Mutex\u003cRefCell\u003cOption\u003cT\u003e\u003e\u003e usage, and it can register unoccupied hardware interrupts as software interrupts with arguments and capacity. However, because it uses a lot of macros, neither RLSRust Language Server nor RARust Analyzer can perfectly auto-complete and lint. So I usually code on bare metal first, making the type right, and then copy and paste into the RTIC project. ","date":"2021-12-27","objectID":"/hello-embedded-rust/:7:0","tags":null,"title":"A First Step in STM32 Embedded Rust","uri":"/hello-embedded-rust/"},{"categories":["tech"],"content":"Memory Allocator alloc-cortex-m: need nightly toolchain. usage With a memory allocator, we can conveniently use vec! etc. The allocator can be config to use external memory after setting up FSMC. ","date":"2021-12-27","objectID":"/hello-embedded-rust/:8:0","tags":null,"title":"A First Step in STM32 Embedded Rust","uri":"/hello-embedded-rust/"},{"categories":["tech"],"content":"RTOS I have tried drone on both WSL and Linux PC but failed to run a hello-world… BTW it seems no longer maintained. Also, there is Tock OS, but you have to write peripheral drivers. The official ST demo only have f3disco and two f4nucleo board, and neither have I tried. I am not optimistic about RTOS in Rust, as many existing drivers are in C. Not to mention the compatibility with existing hal. ","date":"2021-12-27","objectID":"/hello-embedded-rust/:9:0","tags":null,"title":"A First Step in STM32 Embedded Rust","uri":"/hello-embedded-rust/"},{"categories":["tech"],"content":"Useful Crates heapless bitbang-hal nb: although the name is short for non-block, it is usually used to block the code to wait for peripherals. Usage: block!(Serial.write(byte))?; micromath: provide operations on floating point numbers that may be missing in no_std environment ","date":"2021-12-27","objectID":"/hello-embedded-rust/:10:0","tags":null,"title":"A First Step in STM32 Embedded Rust","uri":"/hello-embedded-rust/"},{"categories":["tech"],"content":"Conclusion Embedded rust is definitely acceptable for personal projects. A few disadvantages are: large binaries in debug mode. I have a balancing-bot project in which I would tell you more later. annoying grammar noise I tried embedded rust for some tiny boards’ verifying demo. If the logic isn’t too complex, you can complete the whole project in just a few minutes. I have also tried RTIC for large projects and found a few problems: basically foreground/background system, bothersome when design complex scheduling. much slower that μCOSⅢ. I made a simple serial loop-back, and it could be 50% slower! Maybe I didn’t properly config the clock… Or micrium optimized a lot in handling interrupts. I give up in 2 days, turned to μCOS, because even if I complete it, no one could maintain it lol. Rust’s awesome trait abstraction and embedded-hal as a unified interface, make general driver crates possible. My balancing bot project was done mainly by using crates, which proved the power of these abstractions. This is also the reason STM32’s standard peripheral library and HAL library are so popular in China. However, it inevitably brings extra code with performance trade-off, although you can depend on LLVM, but who knows. Although embedded-hal defines some traits, when out of these traits, hals are usually implemented differently, for example, the GPIO API in STM32F1XX_HAL is very different than in STM32F4XX_HAL. The last thing is only my guess. C++ also has virtual functions, where defining a unified interface is definitely possible. Why they don’t use C++? The virtual table may have performance loss, but the compiler could choose other implementation since compilers for embedded chips are commonly hacked by these companies with some magic. ","date":"2021-12-27","objectID":"/hello-embedded-rust/:11:0","tags":null,"title":"A First Step in STM32 Embedded Rust","uri":"/hello-embedded-rust/"},{"categories":["misc"],"content":"My blog journey. ","date":"2021-11-08","objectID":"/hello-world/:0:0","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":["misc"],"content":"Notion It has been a long time since I thought about having a blog. In 2017 I met notion, where pages could be shared as a link which is definitely OK for a blog. However connecting from China is sometimes unstable and — the appearance. Now I am using notion’s database as a cross-platform bookmark and sometimes a to-do list. ","date":"2021-11-08","objectID":"/hello-world/:1:0","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":["misc"],"content":"Pelican In 2019, I met Github Pages and static web frameworks, and chose Pelican because I’m familiar with Python. Discontinuously developed until summer 2020, learned a lot web-front knowledge. The result was just acceptable. Although there were a few posts, I always had no motivation to update because of the appearance. At that time I got in touch with themes like Hexo Next1, Hugo Meme2 that based on other platforms. And I knew what to expect in my blog: dark mode: I was used to turning it on. But I have a well-lit room so must be on light mode at day time. The mechanism is basically switching between two CSS. Other details like color choices and .svg support are also worth mentioning. responsive: for mobiles, basiclly @media in CSS. Javascripts needed for comples widgets like menu bar etc. toctable of contents: Meme2 meets nearly 99% of requirements, despite of no toc on the side, which forces to read linearly. Better for normal articles rather than technical posts. a good top bar,at least sticky positioned $\\LaTeX$: KaTeX or MathJax markdown syntax extension Chinese: an elegent font,like Noto Serif SC in Meme2 image: support footage, reasonable scaling ","date":"2021-11-08","objectID":"/hello-world/:2:0","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":["misc"],"content":"Hugo ","date":"2021-11-08","objectID":"/hello-world/:3:0","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":["misc"],"content":"Meme2 As mentioned, I tried to integrate a toc on the side but failed. ","date":"2021-11-08","objectID":"/hello-world/:3:1","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":["misc"],"content":"Eureka The document page raised another way to manage posts. ","date":"2021-11-08","objectID":"/hello-world/:3:2","tags":null,"title":"Hello World","uri":"/hello-world/"},{"categories":["misc"],"content":"LoveIt A surprising theme that gives everything and end. However, it seems no longer maintained. May turn to DoIt later. https: //github.com/iissnan/hexo-theme-next ↩︎ https: //io-oi.me recommend if you can read Chinese ↩︎ ","date":"2021-11-08","objectID":"/hello-world/:3:3","tags":null,"title":"Hello World","uri":"/hello-world/"}]