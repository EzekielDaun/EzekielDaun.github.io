[{"categories":["misc"],"content":"UBC Silicon Photonics Biosensor 2022 年 5-8 月，在 UBC 开始了第一份 CO-OP。你说我一个 ME 学生，怎么就拿了 ECE 的 offer 去给 Biosensor 写代码呢？ 入职前就给了两大页 Google doc 的参考资料，要么就是论文要么就是公开课。太多了我就看了前两个视频。正式入职以后上来就甩了三篇论文让看，一周后讨论……一篇文献综述过一遍硅光芯片的基本原理背景知识和发展情况，一篇跟我工作有关的曲线拟合和数据处理，一篇完全看不懂的反应速率分析。同时因为要进生物实验室，上了一周实验室安全课。又花了两周过了一遍实验室设备和软件的使用，搭搭环境，演示了一遍完整的实验流程。前后这么一折腾一个多月就过去了。（我还晚入职了半个月……） 第一个任务是给处理实验数据的 Python 脚本搭个 GUI，再做点小优化。正好之前在看 PyQt/PySide，撸个框还不是分分钟的事儿，结果一看代码傻眼了。单文件全局变量一把梭，主要业务逻辑全在一个 600 行大循环里；纯 C 风格的 Python 代码，状态量满天飞；脚本分析双通道数据，方法是复制粘贴……（实际有多通道需求，也想让我做这个“小”优化，之前他们就手动改脚本多跑几遍……）同时业务逻辑上偶尔还有点“小”bug，希望我“顺手”修了。 看了两天试图重构，最终放弃。前后应该有三个人往这屎山上堆过屎，直到现在这任博后才刚刚加上了版本管理……唉，直接单拉个进程重定向输出，强套个 GUI 给领导展示下效果先。 紧接着开始重写。完全理解原来的代码是不可能了，只能照着大致思路重新摸索一遍细节。首先调库曲线拟合找到峰，然后按最近相邻峰值匹配，不出所料，一个噪声就 GG。 看看频谱图，噪声往往在峰值开始大幅移动时发生，有时是噪声，更多是采样频率不够，分不出上下哪个才是了。兵来将挡，水来土掩。缓存下过去数据，给欠采样段加了个预测。博后说，峰值偏移有时候能超出扫描范围，老代码会在靠近扫描边界时跳到另一条线上去，得，咱也照此办理。 大体上效果好了很多，但遇到真“噪声”——微流道里有气泡导致某段时间峰值变得超诡异，还是一样 GG，尤其这噪声发生在跳转阶段时，还容易跳错。博后说老代码也有相同的问题。唉，主逻辑也得重写了。 再看追踪失败的几个功率谱，要么有噪声尖峰，要么是预期出现的峰被分成了对称的两个。我选择拿峰的形状进行匹配。毕竟拟合之后，一个峰不过就是公式里的几个参数，当成高维向量，算个距离再排个序，不就匹配了嘛。至于峰值偏移超出范围，不拿单独一对峰值作为结果，而是拿两个扫描中的所有峰两两匹配成对算平均偏移，再随便挑个初始峰值往上累加，欧了！ 现在看来两句话就说清楚的事儿，从刚接手、初步尝试、提出新想法再到初步实现，前后花了三周左右，又额外花了一周套上 GUI，至此算是初步完成，又另花了大半个月分发给组里试用，搭搭 CI，和一些小修小补。不知不觉三个半月就已经过去了一大半。 剩下的时间就要摸鱼得多了，一是前段时间劳累过度，二是工作也比较琐碎提不起太大兴趣：给另一套 Python2 代码升级到了 Python3，重新包了一份仪器驱动。另花了两周准备了两份学生暑研 Presentation，分享了这点儿没啥技术含量的破代码。 ","date":"2022-08-25","objectID":"/zh-cn/ubc-biosensor-intern1/:0:0","tags":null,"title":"UBC 硅光芯片 CO-OP","uri":"/zh-cn/ubc-biosensor-intern1/"},{"categories":["misc"],"content":"从设计模式谈开去 单一职责原则（SRP，Single Responsibility Principle） 一个类应该仅有一个引起它变化的原因。变化的方向隐含着类的责任。 里氏替换原则（LSP，Liskov Substitution Principle） 子类必须能够替换它们的基类 (IS-A)。继承表达类型抽象。 依赖倒置原则（DIP，Dependence Inversion Principle） 高层模块 (稳定) 不应该依赖于低层模块 (变化)，二者都应该依赖 于抽象 (稳定) 。抽象 (稳定) 不应该依赖于实现细节 (变化) ，实现细节应该依赖于 抽象 (稳定)。 接口隔离原则（ISP，Interface Segregation Principle） 不应该强迫客户程序依赖它们不用的方法。接口应该小而完备。 迪米特法则（LoD，Law of Demeter） 一个对象应该对其他对象保持最少的了解。 开放封闭原则（OCP，Open Close Principle） 对扩展开放，对更改封闭。类模块应该是可扩展的，但是不可修改。 实习期间重构老代码，看着不忍直视的代码结构，突然理解了所谓“设计模式”云云。 ","date":"2022-08-25","objectID":"/zh-cn/ubc-biosensor-intern1/:1:0","tags":null,"title":"UBC 硅光芯片 CO-OP","uri":"/zh-cn/ubc-biosensor-intern1/"},{"categories":["misc"],"content":"还在更新的陈年老光谱仪 两台同型号的光谱仪，岁数比我还大，有一个激光器插槽和四个传感器插槽。我们的使用场景是用激光器发送波长上的扫描信号，同时用传感器测量芯片的多路输出。因为同时有 C 波段和 O 波段两种待测芯片，买了两台主机和两个激光模块作为两套激光源，切换时只需要调整光纤接法即可。 厂家提供了 DLL 驱动和相关的编程手册，初始化传入仪器地址后，返回文件句柄，作为绝大多数函数的首个参数。2013 年左右，又提供了传感器扩展功能，可以额外添加另一系列的仪器作为传感器，只要把两台仪器的 trigger 相连即可。DLL 升级后，两台仪器可以使用同一套驱动，只需在扫描前向主机注册扩展仪器句柄，随后在主机调用相同的扫描接口函数。但诸如读取传感器实时读数等功能，仍需传入从机句柄。 显然，这种暴露大量底层细节的 C 风格接口完全没有封装，也不面向对象，给程序员带来较大的心智负担。看看还不支持传感器扩展的老代码是怎么做的： 句柄作为实例属性 包装了几个会用到的 FFI 接口 添加了主要接口功能——扫描函数 不错，抽象对于小项目来讲恰到好处。但下一个接手的人是这样支持传感器扩展的：继承原来的仪器类，把所有的属性和方法加个前缀再实现一遍，区别仅仅是传的句柄不一样；对于扫描这种有一定抽象的接口，复制粘贴老实现，然后把所有的仪器调用再追加一份前缀版…… 因为多了一套方法和属性，上层调用者想拿到全部数据，也需要改动调用方式。然后这位接手的大神把所有的调用也复制粘贴了一份前缀版，直接导致单主机无法使用，必须外接扩展传感器使用…… 更多雷人之处暂且不表。虽然没有版本控制，但看着代码里各种带问号的注释、重复的前缀命名，不难想象出这份代码是怎样从一份小而美的项目，被各路大神堆成强耦合屎山的。想要在界面里加个功能，简直无处落脚。 ","date":"2022-08-25","objectID":"/zh-cn/ubc-biosensor-intern1/:1:1","tags":null,"title":"UBC 硅光芯片 CO-OP","uri":"/zh-cn/ubc-biosensor-intern1/"},{"categories":["misc"],"content":"一切皆黑箱 一直以来喜欢理工科的原因无他：某处原理即使再不明白，也能抽象成黑箱，只要强行记住输入输出（的形式 不是背真值表 ），并不影响整个逻辑链条。 我的初中物理老师说：“学物理要全、要联系”1。我想任意理工科都是如此。然而这种联系并不体现为一张完全图，而是更凝练、条分缕析的一颗树。中学时老师常让画思维导图，往往画成树，从没见画成图的。我想 LRU 之所以难写，正是因为要同时维护哈希表和链表两种联系。 软工更是如此，API caller 从不关心库怎么实现。当设计自己的系统层次时，不仅要把被调模块当作黑箱，更要尽可能地暴露最少的细节。因此我们以稳定的接口作为约定，而不关心具体实现。如同 Python 中的鸭子类型，C++ 中的虚函数，Rust 中的 trait…… 与人沟通也有几分黑箱的意思。妈妈让你洗碗，并不是说不用洗筷子，她调用的是名为“洗碗（）”的接口，而不是你“洗（碗）”的实现，或者说，她压根不关心你有没有这个实现，而只是在遵循调用约定，反倒是你暴露了太多实现细节，误以为她在事无巨细地干涉细节；“我上级的上级不是我的上级”，则像是私有属性和私有方法，杜绝了微操“机枪阵地向东二百米”这种事。 然而，真实世界要复杂得多。对于复杂系统，与其构造一个多输入多输出的复杂黑箱来描述，不如看作几个小黑箱的继承/多态与组合。继承/多态自不必说，这里聊聊组合。 代数数据类型Algebraic Data Type, ADT，更具体的，积类型与和类型，是 Rust2 里我很喜欢的一对概念，简单讲就是“既有又有”和“某种之一”。想象一台微波炉，既要选一档火力，又要打开开关，可以说，是两个和类型的积。 再举个例子，多项式。初中数学研究一次函数，记住了斜率、截距；研究二次函数，把求根公式背得滚瓜烂熟。却不再研究三次函数了，老师说，到了大学，我们直接研究 N 阶多项式。 第一次见到用线性代数表示多项式的时候，不禁赞叹其精巧。描述任意一个 N 阶多项式，其实只需要 N 个系数而已。 知乎上看到过一点信息论的皮毛后，便喜欢用信息的观点考虑问题，譬如数字电路和状态机。多项式写出来复杂，其实仅包含了 N 个数的信息。很快，我们的计算从加减乘除，变为了指对幂三反，而到了大学，这类函数又有了新的代号——算子。 较理论的东西我不懂，绝大部分工科应用，不过都是算子的组合。听说控制论的前沿研究，都在用群论的语言描述，不知群论是怎样一种算子，抑或是更高于算子的一种抽象？写到这里，又不禁对数学更敬畏了几分。 ","date":"2022-08-25","objectID":"/zh-cn/ubc-biosensor-intern1/:1:2","tags":null,"title":"UBC 硅光芯片 CO-OP","uri":"/zh-cn/ubc-biosensor-intern1/"},{"categories":["misc"],"content":"工程师——黑箱的有机组合 如果上述之黑箱法可以更好地理解世界，那黑箱的组合，或许是一种改造世界的途径。面向对象、设计模式——软件工程几十年来的实践总结是最好的证明。 北京高考题是出了名的简单直接，江苏同学给我看过他们的卷子，简单看下来，也不过是多个知识点的组合，换句话说，一道题考了北京好几道题的内容。而实际的工程问题，往往都是多个单一问题的组合，鲜有能只套一个模型就完美解决的。 虽然还没学过控制论，但据说传递函数、系统框图，也是如此般将复杂系统化作细粒度的模块处理。 然而他第一节课竟然不自我介绍，因此得外号“全联系” ↩︎ ADT 的概念不仅限于 Rust ↩︎ ","date":"2022-08-25","objectID":"/zh-cn/ubc-biosensor-intern1/:1:3","tags":null,"title":"UBC 硅光芯片 CO-OP","uri":"/zh-cn/ubc-biosensor-intern1/"},{"categories":["misc"],"content":"这两年因各种变故搬了五次家。这次搬进宿舍，希望能安稳地住到毕业。 在北京长大，从小上学走读，唯一经历过的搬家是二年级从院里的营职房搬到团职房，记忆是换了大房子有了自己的房间很开心、要求把墙刷成最淡的蓝色、被姥姥带去家具市场挑了猫和老鼠的窗帘、不理解为什么沙发也可以是硬硬的红木长条板凳加个海绵垫…… 已经回忆不起我是抱着怎样的心情，交了两个超重行李箱的罚款，飞 14 个小时，走进大一宿舍的，但我想一定不是悲伤。我记得走之前给我那串家门钥匙拍了张黑白照片，用高考完所剩无几的文采写了篇矫情的文字。 那串钥匙如今在何处呢？我想不起来。那篇文章存到那里去了呢？我也想不起来。 所幸我还记得那钥匙的模样，记得我在那文章结尾说，总有一天我要拥有一把自己的钥匙。 我想起奶奶癌症中瘦骨嶙峋的模样，想起妈妈声嘶力竭的哭喊，想起父亲佝偻着坐在落满灰尘的阳台默默抽烟，一口，一口…… “他给军队干了一辈子，连套房子都没有……” 2020 与 2021，无疑是一段灰暗的日子。病毒、家事。而我也只能告慰自己没有给这个脆弱的家带来更多的不幸。 明明搬进了宿舍，刚刚建好的新楼，家具用品都是崭新的，房租也减了不少，却为什么感受不到喜悦呢？我本想简单地分享快乐，而落了笔却不由自己的悲伤起来。 眼睛有点酸，向后倒在床上哭了一会儿。 其实五月初就搬进了宿舍，而写作这篇文章的念头也是那时产生的。然而忙碌忙碌，到今天才有空。我昨天去过了超市，今早打扫了卫生，吃过了早饭午饭，才有机会闲下来慢慢地写。 忙碌可以让人忘记时间，忘记忧愁。我可以对着代码看到天黑又天亮，看到低血糖，手忙脚乱地开错了煮方便面的灶；我可以三天刷五套题，写两门课的复习，在阴暗潮湿的一楼小屋里闷一周不出门。但即便再忙碌，也总有公交车上的呆滞、煮面时的无所事事，让我放空大脑，去整理一些若有若无的思绪。有无数个瞬间我脑中闪过些许灵光，却没有机会在那时记录下来。而事后再去回忆，却往往连它们是真实亦或臆想都无法分辨。 我怕我忘记，忘记那些美好的、难过的、再也无法触及的回忆瞬间。 她本科毕业了。 初一的秋游，她靠过来说想要和男生交朋友。臭小子没听懂，没作回应，也没放在心上。临走前的合影她站在半圆形的对面，视线好巧不巧地重合，我想要闪躲，却没躲过她在我心底深深地刻下一抹浅笑。心脏猛烈撞击着胸口，有股冲动想去永远守护这份笑容。 从此她便常常出现在梦里。我偷偷翻遍父母 QQ，找家长群里她的照片，发给自己，删掉记录，再锁进自己手机的相册里，又备份到网盘上；翻同学录背住她的生日当作锁屏密码，查星座相性；找她小学的贴吧账号，想了解她更多一点…… 她是班花，是三好学生，父亲是高级公务员，家住顶级小区。她喜欢音乐，拉一手小提琴，而我对音乐一窍不通；她擅长英语，得奖无数，而我一见单词就头大…… 遑论守护，我甚至不懂该怎样与她产生些许交集。她是耀眼的明星，而我是班里的无名氏。是错觉吧，我想承认，又不愿承认。 “在一无所有的年纪，遇到了最想守护的人。” 我开始拼命地去提升自己，把这渴望而不可及的存在当作前进的动力。“这次比她考的高欸”，“作文进了范文，她会觉得厉害吗”，“我做的这个东西，她会觉得有趣吗”…… 毛头小子们八卦之心旺盛，我要一边躲避着他们的视线，一边偷偷注视着她的背影，幻想着能与她分享我的生活。 甚至，多多少少建这博客的原因，也在于有没有那么一种可能，能让她不经意间地看到呢？ 高中，她去了出国班，虽然不在同一栋楼，却也在同一个校园。家里不太支持我本科出国，有点失落。不过无妨，时间还长。每年开学典礼，会表扬得奖学生，如果那里有我，她会看到的吧。我在社团里混成了老大，没日没夜地在实验室准备比赛。技不如人，拿了个微不足道的铜牌。转过年来的非赛季，却不见了她的踪影。 她去英国读高中了。 有点懵，我赖以前进的支柱，就这样轰然倒塌了。这一年她喜欢上了 love live!，出了 cosplay，竞选了学生会主席…… 明明那么努力地去留意她、追赶她，可无论我再努力，去做什么，她也不会看见了。我假装如常地生活，心底里却失去了最重要的一块。 高二，社团的事情家里慢慢由支持变得反对。首战失利，对我而言再平常不过，可队友换了一拨，人心散了。独自画完了第二版图纸，找加工厂下了单。屋里有暖气，玻璃上结的雾，渺茫了窗外本就漫漫的长夜。 想要上趟厕所，腰痛没起来。我瘫在椅子里突然一阵空虚。各方压力让我我不得不变得功利。没人和我讨论设计，意味着所有后续修改和调整自己承担。队友不积极，只能由我投入更多时间…… 腰痛，十七岁的我竟然会腰痛到起不了床。我思量着未来的出路，脸埋在枕头里，心不甘，泪不干。 虽然现在看来及时止损相当明智，却如同给虎头续了个断掉的蛇尾。我至今仍遗憾，没能给这六年的坚持一个像样的落幕。“力足以至焉而不至，于人为可讥，而在己为有悔”。我是个执拗的人，而这还是第一次主动放弃我所热爱、坚持了许多年的事业。希望不是没有，只是太过微弱，而我又不得不开始瞻前顾后。 我发现失焦的眼睛也可以看东西。 人总在失落时尝试些新事物，比如早起、背单词。越失落，往往成功的概率越大。我开始健身，开始写博客，开始整理收藏夹，开始听些播客亦或鸡汤，开始看动漫…… 我看到《四月是你的谎言》，恨自己不懂钢琴不懂音乐——她最喜欢这部番剧。我看到《月色真美》，回忆起她的一颦一笑，脑海里轰隆地想起那句话。女孩子果然还是成熟的早些啊。 此情可待成追忆，只是当时已惘然。在互联网的角落里一个人发癔病，我也知道自己多少有些病态。只是曾经沧海难为水，此后再璀璨的星星，都在白月光前相形见绌。 高考、疫情、学业、实习，没有她的五年转瞬即逝，这段回忆明明快要淡忘。一场没有她的同学聚会，又将往事重提。 她比我们晚一个月才入学，那天早上，班主任安排她坐在我原来的位置上。她闺蜜跟我讲，因此，我便成了她中学里第一个认识的同学，而且印象不错。 “哦，那真是荣幸啊”。琐事中麻木的心没能掀起什么波澜，话题也随后转了开去。似乎她之于我已经变成了一个符号，能在我低迷时有点动力，而她真正怎么想，我已经不在乎了。 人们说失去了才懂得珍惜，而只有真正的失去过，才能感到这句话的沉重。所谓白衣飘飘的浪漫年代，所谓逝去的青春，以前总拿来调侃，而现在大概也要真的逝去了吧。 我不由得去为未来打算，为不久的将来打算。不是基于模模糊糊的畅想，而是冷冰冰的数字。 生命里那个重要的人还没有出现，我也没做好迎接 ta 的准备。九年后我似乎仍然一无所有，甚至在浪潮中独善其身也变成了一种奢望。学士服里的她的微笑熟悉又陌生，朋友圈里告诉大家要回国在家待一段时间。 同样的九年，人家衣锦还乡，而我连家的概念都变得模糊了起来。 这两年听到《稳稳的幸福》都会不由自主地哽咽。各处奔波是一方面，更多来自于那些不安的、没有归宿的深夜。家已经不在了，我只想简简单单地有个安稳的栖身之处，去放下那颗悬着的、冰凉的心。 思绪很乱，也太久没动笔了，一篇文章从下午写到深夜。这个周末过去，又要转投入忙碌之中。 或许忙碌才是生活的本来面目，但愿我能常常在今后的忙碌之中，从苦涩的回忆里如此咀嚼出一点况味来。 一周以后刷到了这个视频： 看到一条评论，把它记录在这里： 我也曾经野心勃勃的想要干翻这个世界 对自己讨厌的人，讨厌的规则嗤之以鼻 但我现在不这样了 我在不经意间被捶的老老实实 几乎没有挣扎的滑向了平庸与世俗 大概也许我本来就是一个俗人吧 可那些热烈的，无畏的岁月却又那么真切的存在过 以至于我每每看到与之有关的一切总会热泪盈眶 那些眼泪仿佛在哀悼那个曾经的少年 ——泡泡糖葫芦娃哈哈 ","date":"2022-06-25","objectID":"/zh-cn/the-sixth-move/:0:0","tags":[],"title":"第六次搬家","uri":"/zh-cn/the-sixth-move/"},{"categories":["learn"],"content":"简要总结下本科课程 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:0:0","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"First Year 大一，可以说就是把国内高中的东西拿英文重新上一遍，压力很小，几乎每天都有时间健身。两个工程导论课还算有意思，小组讨论的形式很锻炼口语。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:0","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"APSC 100/101 工程学导论，主要介绍工程项目的设计流程和方法，以及与环境和经济的关系。有教授 SolidWorks 的基本用法和 3D 打印技术的简单介绍。两个动手的项目，分别是 Term1 的纸板椅子和 Term2 的 Arduino 夹子。我们纸板椅的设计以折叠为主，用 SW 钣金功能极大简化了设计难度。实测 75kg 的人直接屁股坐上去不成问题。不过最后测试时重量是压在两只鞋上，导致只有部分结构在实际承重。Arduino 夹子没啥好说的，编程部分就是个超声波和舵机，非常简单，更多在动手剪铝板压铆钉上。 课程里几个印象深刻的点： Design Process 核心在于，将问题分解为多个维度的评价标准 (evaluation criteria), 并对头脑风暴出来的众多方案中可行的几个打分。 C-Sketch 非常有趣的头脑风暴方案，避免了 “某人看起来很专业所以听他的就好了” 这种事发生。做法是每个人 10 分钟画一张画表达自己的想法，期间不许语言交流。画完后传给下个人，下个人继续用 5 分钟把他对这个方案的理解补充上去，以此循环，直至轮转完一圈。如果说完全没有绘画技巧，那理解起来就比较抽象了。最好学一下基本的透视，方块和曲线的画法。 关于设计流程的部分其实来自某教授的一本书，虽然内容不错但也太贵了吧…后面 MECH2 还会再提到。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:1","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"APSC 160 少儿编程难度的 C 语言，当然人家正式名称叫做编程在工程中的应用… 考试是手写代码。平时的 lab 很有意思，有一套 daq 系统和外界交互，需要 Visual Studio，因为 daq 以及模拟器的库是 Windows 平台的 dll… 当时对编译过程一窍不通的我试图用 mingw gcc 未果，不过理论上应当是可以的。 推荐教材是本没听说过的书 Programming in C, 虽然课并没按教材讲，而且只覆盖了 1/3 不到的内容，但我在暑假把整本书看完了。难度很低，没有算法，没有任何宏之类的奇技淫巧，可以说是很好的 C 语言入门材料了。说来也怪，我靠学 C 把当初看廖雪峰 Python 没看懂的 OO 搞明白了。看到结构体和函数指针，立马手撸了个多态; 结构体套结构体，也算实现了继承; 至于封装…不知道该怎么实现，毕竟结构体的声明里一定暴露了所有成员呀… ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:2","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"PHYS 157/158 普高难度的物理，只是用英文讲，没啥好说的 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:3","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"PHYS 170 力学初步，极坐标柱坐标转换什么的有点烧脑，不过背公式就完了。考试非常简单。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:4","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"CHEM 154 普高难度的化学，加上一些定性的东西需要背一下，电子轨道理论高中没学，需要补补。难度基本在背单词 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:5","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"ENGL 112 英语课，学术写作，讲一些用词行文以及引用参考文献的规范。说实话听不太懂，final 直接让写一篇 400 词文章。我托福都没写过这么多… ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:6","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MATH 100/101 微积分，国内大先那套 $\\epsilon-\\delta$ 语言真的是上吐了，这里不讲推导所以简单很多，毕竟工科嘛，会用就行。作业题感觉很简单但不知道为啥 final 分不高… ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:7","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MATH 152 线性代数入门。到特征值特征向量以及特征值法解微分方程就结束了，难度不大。我的 Prof Yuexian Li 是个中国人，以前看过简历，似乎是中科大的本科，然后 80 年代中科院的研究生！课上的非常好，以至于后来我去看大家吹的 3B1B 只觉得无感，当然线代这玩意儿入门真就是会者不难。有 Lab 会教你 MATLAB 的基本使用。总的来说很实用，体验很好的一门课。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:8","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"FREN 100 Summer 赶上疫情，上的网课。用英语讲的法语课。以敢开口为主，气氛比较欢乐，当然单词肯定是得背。考试有口语和笔试两场。感叹一下加拿大同学确实很多都有法语基础呀… 和我一组的一个同学是歌剧系的，唱过法语歌词。另外她家在 Newfoundland，当时每天顶着时差上课… ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:9","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"LING 101 一样的网课，上课就像听故事。主要讲了国际音标以及从音位推断一些语言的关系。因为本身对这方面很有兴趣所以上起来很舒服，刷知乎看到方言还有古汉语等等话题总算能看懂一些了。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:1:10","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MECH2 大二，因为疫情回国全程网课。机械系大二比较特殊，全年级上同一套课表，没得选。而且 Term1 分成三段：机械制图和 Arduino，几门正课 和 工程导论。Term 2 也是分了两段，正课和最后的小项目。对于我们这些在另一个半球的学生，系里很贴心的准备了所有课的录播，lab session, tutorial, weekly quiz 也都有两个时区。Final 也选在了对大部分学生都合适的时间。相比其他专业的同学不得不上夜校，真的要吹爆 MECH. 另外，考试被安排在了大部分同学都合适的时区。而且由于网课，Symbolab 什么的全凭自觉，但我用 Python 写几个求解器应该不过分吧。 大二总算有那么一点点大学的样子了，大一上得太舒服，都快忘记学习的感觉了。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:2:0","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MECH 230 Arduino 玩 Autodesk 出的一个模拟器, 极其简单。 机械制图 上这课时我在隔离酒店…要用的图纸却寄到家里去了…只好拜托防疫人员帮忙打印…体验极差。内容主要是三视图，剖面图和尺寸标注。但相贯线之类的却只要求画个大概就行… ANSI 和 ISO 两套标准都讲了，但考试还是 ANSI. ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:2:1","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MECH 232/233 继续工程导论，在 APSC 100/101 的基础上继续扩展。强制买某教授的书确实有点恶心，还没法寄国内，不过还好有热心同学拍照分享。 232 直接虚空设计，算算就完事儿了。233 要求做个爬绳器，因为疫情，最后性能就比个乐，不算分。既然在中国那自然淘宝铝板定制走起。轴承什么的更是想选啥买啥。可惜发货都在深圳，早知道让寄深圳那个同学那边去好了。还省得我组装了 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:3:0","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MECH 221/222 所谓正课，倍速大屏看录播真的不要太爽。 MATH 常微分方程，雅可比矩阵 和 多元微积分，以及拉普拉斯变换，挺基础的内容，有配套 MATLAB lab. 还是，不讲推导所以难度不大。 Dynamics 刚体动力学。坐标变换，角动量，阻尼振动什么的。概念不难，本质上还是牛顿定律，但算起来有些复杂。 Solid Mechanics 固体力学入门。拉压应力/应变，剪应力/应变的计算，莫尔圆/应力圆，轴上的扭矩，梁的弯矩。内容其实没多少，后面 MECH360 两节课就把这些全带过了。教授也是个中国人，但她讲得实在是太太太慢了…我开两倍速都嫌慢… Statistics 统…计？内容很少的一节课，很快就上完了。写这总结的时候甚至想不起来上了啥… 中位数，均值，众数，简单讲了下最小二乘和置信区间。 Circuit Analysis 电路分析。电流源和电压源的两种等效电路，电容电感，交流电的复数表示和 RLC 电路。 Material 材料学导论。晶体结构，塑性脆性，蠕变，金相。很多定性的东西。已经忘得差不多了。 Fluid Mechanics 流体力学入门。介绍一些基本概念和量纲分析，主要围绕雷诺数，还有管内的流动分析以及水泵。教授声音软软的，但讲课废话有点多…而且还有额外的视频要课前预习…这几乎双倍工作量了吧？ Thermal Dynamics 热力学入门。理想气体状态方程，焓，熵，相变，几种热力学过程和它们的 TS 图。没啥，算就完事儿了。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:3:1","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MECH 226 技术写作。由一个 89 年已经在乌克兰毕业，95 年又来加拿大读博的英语文学专业乌克兰老太太念 ppt. 这门课贯穿整个大二。内容是怎么在公司里写汇报 233. 对于非母语者确实有难度，也确实很实用。但是吧，至少我，这辈子应该达不到这门课能拿 A 的水平了…毕竟语言这东西，尤其是写作，母语者真的一眼就能看出别扭的地方。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:3:2","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"Mechatronics Year 3 机械电子方向大三分两年：Year 3 和 Year 3.5. 大学上到这时候终于算是学了点实用的东西。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:4:0","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MECH 306 概率统计和实验设计。标准差，均值标准差，正态分布，学生 T 分布，假设检验，F 检验，(配对)T 检验，中心极限定理，贝叶斯定理，泊松分布，指数分布，二项分布，加权平均，拟合，机器学习简介，滤波器，主元分析Principle Component Analysis. 哗哗列了一大堆，感觉都是挺重要的主题，但教授上课和课程内容设计实在太差. 要不是我高中上过概率论与数理统计先修，真的不知道这课在讲什么。概率论上来不讲符号直接放公式，排列组合维恩图什么的直接跳过。统计也一样，上来连随机变量定义都不讲，一个概率密度直接把大家全搞懵。公式推导一概不讲，背住就完事儿。 实验部分也只能算差强人意。三个安排好的实验要从学校拿材料自己在家做，其中流体和热力学实验偏差实在太大，硬件问题也基本无法解决。最后一个自己设计的实验还算勉强，但其实绝大部分组都是搞点数据然后 T 检验或者 F 检验再画个图完事儿，半定量甚至纯定性的分析为主，仔细想想也没有任何成就感可言。 考试体验也极差，期中上课一嘴带过的二项分布做了一整道大题。期末因为每年讲课内容还不一样，历年考题完全不能参考，复习都无从下手。总之是非常让人迷惑的一门课。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:4:1","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MECH 360 材料力学。梁的弯矩，柱屈曲，能量分析，静不稳定梁的分析，不对称弯曲，剪力中心等等。相当友善的一门课。内容不多，难度不大，所以教授讲得比较慢 习题课 TA 也是. 公式也都很好理解。作业判得比较严，甚至多算了一些东西也要扣分。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:4:2","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"MECH 375 传热基础。传导，对流和辐射，热交换器。教授讲得略微有些奇怪，一上来听着会有些迷惑，但上到最后发现本质其实就是热传导方程 + NS 方程。平时作业题来自某参考书，和讲课内容基本不搭，TA 直接念标答。不过考试还好，因为基本只能参考经验公式，并不会考手解微分方程，按计算器就完事儿了，还有一部分概念简答题。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:4:3","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"ELEC 302 模电。二极管，PN 结，运放，三极管和 MOS 管。内容多但难度不大，教授语速极快，上课容易跟不上，不过回看 PPT 基本都能看懂。PN 结物理原理有点迷惑，不过明白了也就是一层窗户纸。考试允许带 4 页双面笔记，相当友善。 Lab 部分挫败感极强，四个 LAB 我们两个都没做出来…应该是器材的原因。Lab TA 几乎没有任何作用。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:4:4","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"ELEC 343 电机入门。三相电，电感，磁链，变压器，直流，步进，同步，无刷，感应电机的基本原理和简单分析。内容有相当的广度和深度，这学期投入最多的一门课。教授讲得也很好。尤其学到磁链，电感，交流，qd 坐标系等等需要数学的地方，能切实感受到数学在工科中的美妙应用。直流和无刷电机还给出了 SimuLink 模型，我也顺带入了个 SimuLink 的门。Lab 工作量相当大，有大量的计算。有时发现数据和理论不符，怀疑是误差，但仔细分析发现还是自己理解不到位，理论值算的有问题。Lab 后面几个问题也相当有深度。摆烂了一个 Lab 实在是很抱歉。 习题和实验课的时间安排有些迷惑，经常上课还没讲就需要做实验做题…因为这个还导致我们某个 Lab 没做出来…还好有去年疫情期间录好的的视频可以抄数据参考。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:4:5","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["learn"],"content":"CPEN 312 数电和 8051 汇编。如果看过 Code: The Hidden Language of Computer Hardware and Software编码：隐匿在计算机软硬件背后的语言 这本书，那这门课可以秒杀之。课程分为独立的两段：期中前数电，主要是布尔代数，锁存器，触发器，同步异步计数器，状态机和多路选择器。布尔代数虽然不讲数学证明，但会考 K-Map 化简和纯 NAND 搭任意逻辑等等，虽然之前有过一点了解，但真正学起来还是有些难度。Lab 用 FPGA 做。期中后就是 8051 汇编。讲课内容对新手不太友好，最好有一些计组基础或者单片机 (非 arduino) 经验。除了基本的汇编指令，寄存器，栈和 51 内存结构，还讲了： 数学计算 负数的补码表示 Binary \u003c–\u003e BCD 大于 8 位的无符号加减法 大于 8 位的无符号乘除法 (简单介绍) 中断和定时器 不考但其他年份讲过所以只放出 PPT 的内容： 串口：RS232 SPI 对我而言很轻松的一门课，从此无惧汇编，了解了许多底层细节。老教授这门课教了 20 多年了，FPGA 的 51 软核，汇编器，调试器和 IDE 都是他自己写的。PPT 后面的练习题虽然不讲，但值得一看，比如 51 的栈传参。FPGA 板子是 Intel University Program 的 Altera Cyclone V，优惠价 99 美刀，但还是很贵啊…强制买还是有点肉疼。 ","date":"2022-04-13","objectID":"/zh-cn/course-summary/:4:6","tags":["UBC"],"title":"我的 UBC 课程总结","uri":"/zh-cn/course-summary/"},{"categories":["tech"],"content":"大三才做出来平衡小车实在是太菜了…分享一下过程和学习笔记。写这篇时还没有学过任何控制相关的课程，如有错误请见谅 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:0:0","tags":["Rust","Embedded"],"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"平衡小车 PID 原理 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:1:0","tags":["Rust","Embedded"],"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"PID 网上有太多 PID 解析了，这里不多赘述，讲一下我的理解 小时候一定拨过钢尺，振幅越来越小最后不振了。能来回振是因为钢尺有弹性，能停下是因为有阻尼。弹簧 + 阻尼一般能解决大部分问题，而这其实就是 PD 控制器。二阶线性微分方程从原理上解释了这一切。忘光了现学的… $$ my’’+cy’+ky=f(t) $$ 用 RLC 电路理解也可以 假设这些参量均大于零，即特征方程的解$r_1 , r_2$的实部$\\frac{-c}{2m}$小于零，则微分方程的通解$y=K_1 e^{r_1 t} + K_2 e^{r_2 t}$一定收敛。理想情况是临界阻尼$r_1 = r_2$, 此时通解为$y=Ke^{rt} + Kte^{rt}$ 因此，PD 控制器可以理解为给原本的模型套上了弹簧和阻尼来使它稳定。然而，对于有某些固定载荷的情况，被控量最终会根据 P 稳定在某个偏离目标量的地方。积分项 I 的引入就是为了消除这种稳态误差。 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:1:1","tags":["Rust","Embedded"],"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"姿态环 将小车当前的倾角作为 PD 控制器的输入，这里注意各参数的符号。小车前倾，我们就向前加速赶一步，后倾就向后加速。但这种控制方法并不稳定，即便参数调试得非常好，最后小车总是加速向一侧倒下。这是因为电机速度具有上限。当小车姿态已经归中但底盘仍有速度时，因为比例部分几乎为零，电机输出一个极小值，产生近似刹车的效果，使得小车快速点头，反而可能产生了比一开始更大的倾角。 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:1:2","tags":["Rust","Embedded"],"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"速度环 为了解决这个问题，我们引入了速度环。速度环以车轮转速为输入，其输出作为姿态环的目标位置输入，即小车有前向的速度时，将姿态环的零位调整到一个后倾的角度，让姿态环多赶一步。姿态环采用 PD，速度环采用 PI. 两套控制参数的调试还是有点麻烦，理想过程是先调姿态 P 到一个不错的响应，再调姿态 D 到能够站立一小会儿，再调速度环。 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:1:3","tags":["Rust","Embedded"],"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"中断引发的故事 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:2:0","tags":["Rust","Embedded"],"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"树莓派 我总觉得 arduino 更像个玩具，买了没啥大用，而树莓派也有 GPIO 口，还是个 Linux PC，怎么看可玩性都更高一些。于是买了个最丐的 2G RAM 4B 进行开发。主要使用 C 语言和 Wiring Pi. 硬件部分淘宝解决，上来先驱动下各个部件： 直流电机 驱动器是常见的 L298N. 简单说就是两个引脚电平调方向，一路 PWM 输出控制电压。PWM 采用树莓派的 pwm0, pwm1 两路硬件 pwm, WiringPi 有对应的函数，非常好写，注意一下引脚号即可。 MPU6050 I2C 协议的六轴陀螺仪加速度计。MPU6050 有内置的运动处理器 DMP，可以直接以四元数的形式输出融合后的姿态，诶！?什么叫融合…直接读不就完了？ 节约主机计算资源，不过不能通过一般的方式驱动，芯片手册里也没有驱动相关的信息。官方提供了 MSP430 上的例程，代码量比较大，核心是要传一串神秘代码来开启 DMP 功能。我找了半天适合树莓派的 dmp 库只发现了这个 C++ 库. 虽说也可以自行移植，但当时我这个小白办不到啊… 唉，在 C++ 里写 C 吧。 编码器 硬件上它产生两路 90° 相位的方波，每转一圈会产生固定数量的跳变。通过读一路跳变时另一路的电平来确定当前旋转方向，往往用中断驱动。真是神奇啊。 WiringPi 包装了方便的函数来让我们注册中断处理函数： int wiringPiISR (int pin, int edgeType, void (*function)(void)) ; 这里只需要传入函数指针，即可在中断发生时调用注册的函数。注意这个函数的返回值和参数都是void, 那么怎么与外界联系呢？答案是使用全局变量： long long COUNT; void myISR(void); void myISR(void){ COUNT++; } int main(void){ wiringPiSetup(); /* Some code */ wiringPiISR(pin, INT_EDGE_BOTH, myISR); /* Some code */ } 这样，每次中断发生时，COUNT 的值都会自增。因为编码器计数非常快，这里把 COUNT 定义为 long long (64 位) 贴一下我的 C 代码，成功驱动了电机和编码器吗？, 还可以在 SSH 中按q退出，可以说距离完成只差控制部分了： motor.h #include \u003cpthread.h\u003e #include \u003cstdbool.h\u003e #include \u003cstdlib.h\u003e #include \u003cunistd.h\u003e #include \u003cwiringPi.h\u003e #define PIN_MOTOR1 26 #define PIN_MOTOR1_IN1 6 #define PIN_MOTOR1_IN2 27 #define PIN_MOTOR1_OUT1 28 #define PIN_MOTOR1_OUT2 29 #define PIN_MOTOR2 23 #define PIN_MOTOR2_IN1 22 #define PIN_MOTOR2_IN2 21 #define PIN_MOTOR2_OUT1 24 #define PIN_MOTOR2_OUT2 25 #define START_POWER 120 typedef struct smotor { const short PIN; const short PIN_IN1; const short PIN_IN2; const short PIN_OUT1; const short PIN_OUT2; const short DIR; const void (*run)(); const int (*readSpd)(); long long lastPos; } Motor; int motorInit(void); static void motor(Motor *pmotor, int power); static int readSpd(Motor *); static void readEnc1A(void); static void readEnc1B(void); static void readEnc2A(void); static void readEnc2B(void); Motor leftWheel; Motor rightWheel; motor.c #include \"motor.h\" int motorInit(void) { if (!wiringPiSetup()) { /* set interrupt response */ wiringPiISR(PIN_MOTOR1_OUT1, INT_EDGE_BOTH, \u0026readEnc1A); wiringPiISR(PIN_MOTOR1_OUT2, INT_EDGE_BOTH, \u0026readEnc1B); wiringPiISR(PIN_MOTOR2_OUT1, INT_EDGE_BOTH, \u0026readEnc2A); wiringPiISR(PIN_MOTOR2_OUT2, INT_EDGE_BOTH, \u0026readEnc2B); /* set pin mode */ pinMode(PIN_MOTOR1, PWM_OUTPUT); pinMode(PIN_MOTOR1_IN1, OUTPUT); pinMode(PIN_MOTOR1_IN2, OUTPUT); pinMode(PIN_MOTOR1_OUT1, INPUT); pinMode(PIN_MOTOR1_OUT2, INPUT); pinMode(PIN_MOTOR2, PWM_OUTPUT); pinMode(PIN_MOTOR2_IN1, OUTPUT); pinMode(PIN_MOTOR2_IN2, OUTPUT); pinMode(PIN_MOTOR2_OUT1, INPUT); pinMode(PIN_MOTOR2_OUT2, INPUT); return 0; } else { return -1; }; }; void motor(Motor *pmotor, int power) { digitalWrite(pmotor-\u003ePIN_IN1, ((power * pmotor-\u003eDIR) \u003e 0)); digitalWrite(pmotor-\u003ePIN_IN2, ((power * pmotor-\u003eDIR) \u003c 0)); pwmWrite(pmotor-\u003ePIN, abs(power) + START_POWER); }; int readSpd(Motor *pmotor) { long long pos = pmotor-\u003elastPos; usleep(5000); return (pmotor-\u003elastPos) - pos; }; void readEnc1A(void) { (leftWheel.lastPos) -= leftWheel.DIR * (((digitalRead(PIN_MOTOR1_OUT1) == digitalRead(PIN_MOTOR1_OUT2)) \u003c\u003c 1) - 1); /* equivalent to (motor1.lastPos) += motor1.DIR * ((digitalRead(PIN_MOTOR1_OUT1) == digitalRead(PIN_MOTOR1_OUT2)) ? -1 : 1); */ }; void readEnc1B(void) { (leftWheel.lastPos) += leftWheel.DIR * (((digitalRead(PIN_MOTOR1_OUT1) == digitalRead(PIN_MOTOR1_OUT2)) \u003c\u003c 1) - 1); }; void readEnc2A(void) { (rightWheel.lastPos) -= rightWheel.DIR * (((digitalRead(PIN_MOTOR2_OUT1) == digitalRead(PIN_MOTOR2_OUT2)) \u003c\u003c 1) - 1); }; void readEnc2B(void) { (rightWheel.lastPos) += rightWheel.DIR * (((digitalRead(PIN_MOTOR2_OUT1) == digitalRead(PIN_MOTOR2_OUT2)) \u003c\u003c 1) - 1); }; Motor leftWheel = { PIN_MOTOR1, PIN_MOTOR1_IN1, PIN_MOTOR1_IN2, PIN_MOTOR1_OUT1, PIN_MOTOR1_OUT2, .DIR = 1, motor, readSpd, .lastPos = 0, }; Motor rightWheel = { PIN_MOTOR2, PIN_MOTOR2_IN1, PIN_MOTOR2_IN2, PIN_MOTOR2_OUT1, PIN_MOTOR2_OUT2, .DIR = -1, motor, readSpd, .lastPos = 0, }; main.c #include \"motor.h\" #include \u003cstdio.h\u003e void *usrInterrupt(void *arg); char usrInput = ' '","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:2:1","tags":["Rust","Embedded"],"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"Rust 与并发编程 假期短暂，我的第一次尝试以失败告终。之后在网课之余，机缘巧合，我接触到了 Rust 这门语言。简单看了看 the book 发现还不错，于是花了三周多，在网课之余把它看完了。其中 ownership 和 borrow checker 非常特别，它们规定： 对一个变量的引用 (指针), 只能存在： 有且仅有一个独占引用(写者), 且没有共享引用 (读者), 或 没有独占引用 (写着), 任意多个共享引用 (读者) 换句话说，只要有人在写，其他任何读写操作都不能进行。等等，我之前的编码器计数是怎么实现的？违背了这个规范呀！ 一年后的今天，让我们彻底了结这个问题：数据争用. 我用的 Raspbian 是 32 位版本，其 long long 被定义为 64 位有符号整型。换句话说，绝大部分对 64 位整数的操作都不能在一条汇编指令中完成。因此，当测速线程修改了速度变量却还没完成时，有可能被调度打断 (raspbian 并不是实时系统). 此时读取这个变量就会发生数据争用的问题。至于 C 代码为什么没问题，是因为仅仅打印了编码器计数，而没有另起一个测速线程。中断处理速度极快且不会被其他线程抢占，而中断发生的频率又没有高到能够常常打断主线程中的读取过程。我翻 makefile 才发现我 C 开了 O3, C++ 啥优化也没开… 那么，合理的解决办法是什么呢？ 原子操作 atom 是不可分的意思，原子操作就是不会被打断的操作。缺点是需要处理器支持，且一般只能操作长度不大于处理器字长的数据类型。关于 Ordering 的选择，如果只需要原子性，使用 Ordering::Relax 即可，用于计数的话再适合不过了。在多核情况下还需要考虑内存一致性来选择 Ordering, 最严格的一般是 Ordering::SeqCst. 互斥锁\\读写锁 (普通线程) 对于有操作系统 (包括实时系统) 情况下普通线程间的资源共享，可以使用这两种锁。详见 the book. 如果获取锁失败，线程可以选择出让控制权让操作系统先调度其他线程。 临界区 (中断) 由于中断总能抢占当前线程，除非你允许中断处理函数在资源被占用的情况下漏掉中断不处理，否则主线程中的锁形同虚设。有的处理器可以暂时关闭所有中断，这样当前正在执行的任务就不会被打断。如果使用 rust，还需要配合 Mutex, RefCell 等来通过语法检查，详见 the embedded rust book. 缓冲区 还有一种取巧的做法，使用内存来通信。环形缓冲区可以实现为数组 + 头尾原子指针，我们可以让发送端独占头指针，接收端独占尾指针，每次发送/接收，都向内存中写入/读取数据后操作指针自增。只要缓冲区够大且接收端处理速度大于发送端发送速度，一般不会漏掉消息。保险起见还可以在发送和/或接收时加上头尾指针判断 如果现在让我重新设计树莓派编码器测速逻辑：我会使用中断操作原子类型计数，用互斥锁包装速度全局变量，让测速线程和主线程抢锁，来保证对速度变量的操作不会产生竟态条件。 不过，后来实习接触了 STM32 这样的单片机，拿来做平衡小车足够了，反观树莓派 4B 还需要 5V3A 供电，我还特意买了微雪的电池扩展版，头顶两节 18650 简直不要太笨重，于是树莓派就光荣的吃灰了。STM32 的定时器具有编码器功能，可以通过每次读取后清零的方法获取速度，配合定时器中断测速即可。不过我用 rust 实现的版本因为软件 I2C 的库必须要一个定时器，导致没定时器拿来做中断了… 只好用延时实现。 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:2:2","tags":["Rust","Embedded"],"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"多传感器融合 还记得 MPU6050 有个 DMP 库吗？后来转向 Rust + STM32 后，因为没找到能用的 DMP 库，我就用的六轴原始数据。确定角度还不简单？三轴加速度和重力一比较就完事儿了，我用的库还有现成的包装 get_acc_angles(\u0026mut self) -\u003e Result\u003cVector2, Mpu6050Error\u003e. 快快拿来一试，再加上现成的 PID 库, P 输入用刚才获得的角度，D 输入直接用陀螺仪，不到一个小时代码就编译通过了。不得不说，Rust 这点真的香：99% 的情况下能过编译就能跑. 小车拿在手里，前倾就向前加速，后倾就向后加速，各参数极性正确！但是 PID 参数我竟然调了三天都没调明白…连最基本的姿态环都几乎无法实现。最好的一组参数也只能维持个 10 秒钟左右。我干脆两手捏住轮子当成纯倒立摆，诶！?怎么这都稳定不了？看了输出才发现，获取到的角度抖动太大！那就加平滑滤波！可加了滤波也没法稳定，这让我又犯了难… 想想也是，这小车本身就在抖动，读出来的加速度可不仅仅是重力加速度。那要怎么确定角度呢？有以下几种办法： ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:3:0","tags":["Rust","Embedded"],"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"互补滤波 $$ \\theta = k \\cdot \\theta_{\\text{acc}} + (1-k)\\cdot \\int{{\\omega}dt} $$ 通过对读取到的角速度 $\\omega$ 积分，我们也可以得到一个角度数据 $\\theta_\\text{gyro}$. 当然这个数据会因为累加存在一定的误差。之前提到从加速度计和重力方向也可以得到一个角度数据 $\\theta_\\text{acc}$, 我们把两个数据分辨乘以一定的权重后相加，作为上述控制系统的输入。在实际实现时，往往采用递推的方式将其改写为： $$ \\theta_{i+1} = k \\cdot \\theta_{\\text{acc}} + (1-k)\\cdot ({\\theta_{i} + \\omega dt}) $$ 还可以根据当前两个数据的大小来动态调整权重，比如：当加速度计测到一个较大数据时，更相信陀螺仪。当陀螺仪数据很小时，更相信加速度计。 本来想用 Rust 在 STM32 上实现互补滤波的，但因为之前提到的定时器不够只能在 main 函数中 delay 测速来完成整个控制循环，实践发现这个延时并不稳定，导致陀螺仪积分要乘的 $dt$ 不好确定。最后还是决定转回 C，有 DMP 不用，何苦呢。 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:3:1","tags":["Rust","Embedded"],"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"卡尔曼滤波 久仰卡尔曼滤波大名，可惜我水平不够还没看明白原理… 如果有现成的库可以使用，自然是拿来主义。我尝试了 rust 的 adskalman, 但因为编译出的二进制太大没能成功烧录。 关于卡尔曼滤波的原理，希望自己以后可以补充完全。 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:3:2","tags":["Rust","Embedded"],"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["tech"],"content":"总结 最后用 C 和 DMP 完成的版本效果如下。时间紧张，代码质量太差，就不献丑了。 平衡小车，搞明白原理其实并不难。如果我一上来就选了 arduino，或许就不会接触到 Rust 和 STM32. 从树莓派一路踩坑下来，反倒收获了更多的知识和经验。 ","date":"2021-12-28","objectID":"/zh-cn/balancing-bot/:4:0","tags":["Rust","Embedded"],"title":"平衡小车","uri":"/zh-cn/balancing-bot/"},{"categories":["work"],"content":"2021 年大二结束后的暑假，托关系找了份实习。一家医疗器械公司，主营体外检测仪器和配套试剂。安排我到他们做快速荧光 PCR 的项目里。说起来也蛮有趣，我一个臭机械本科生，六个月里竟然前后干了机械电子软件三种工作（大约各两个月）。流水账式地记录下几个主要内容。 ","date":"2021-12-28","objectID":"/zh-cn/my-first-intern/:0:0","tags":["Rust","C/C++","RTOS","SolidWorks","PCB","Embedded"],"title":"第一份实习","uri":"/zh-cn/my-first-intern/"},{"categories":["work"],"content":"软件原型 仪器准备投放到基层医院，所以需要一个比较易用的界面，方便操作员快速培训上岗。正好我入职啥也不懂，安排我设计下软件原型。咱也不是艺术生，配色啥的咱也不懂，主要就是设计 UI/UX 的操作流程，点这个按钮跳到什么什么界面这样。原型软件领导直接给买了两份 axure，不过似乎 figma 更火的样子。现在看来软件原型也确实是一个很好的入门项目，快速熟悉了基本的仪器原理和运行流程。 ","date":"2021-12-28","objectID":"/zh-cn/my-first-intern/:1:0","tags":["Rust","C/C++","RTOS","SolidWorks","PCB","Embedded"],"title":"第一份实习","uri":"/zh-cn/my-first-intern/"},{"categories":["work"],"content":"步进电机驱动调研 唉，下个学期才开电机的课，就当提前预习了吧。驱动器一般分为脉冲型和总线型。 脉冲型： 你只需要发脉冲，一个脉冲走一步，全步半步微步什么的可以用其他引脚配置。缺点是运动加减速全部都要自己控制，实时性要求比较高，如果要求闭环控制则更复杂；胜在价格便宜，一片不过十几块钱 总线型： 驱动模块： 当时正在使用一款国产 CAN 总线驱动器，小毛病不断而且价格不菲，一台机器要 12 个，每个要 300 多元，成本上希望压榨一下。领导的意思是自己搞个 FPGA 接脉冲型芯片，12 个驱动器一起控制了。我想了想 FPGA 开发难度实在是有点大，而且只带 12 个是不是有点大材小用 关键是项目里没人会 驱动芯片： 推荐了 Trinamic 的 TMC5160，一个是功能强效果好，另外公司里另一个项目组就选了同款芯片，有打好的电路板可以直接拿来用。芯片一片 80 左右，单片机用 F103 最低配都绰绰有余，也可以用个资源多的型号同时控多路 SPI 挂多个芯片。算上外围元件 + 制板费也比原来低不少，而且还不用自己开发 ","date":"2021-12-28","objectID":"/zh-cn/my-first-intern/:2:0","tags":["Rust","C/C++","RTOS","SolidWorks","PCB","Embedded"],"title":"第一份实习","uri":"/zh-cn/my-first-intern/"},{"categories":["work"],"content":"荧光镜片组外壳迭代 同类机器一般用激光器做光源，虽然效果超棒但价格也很美丽。我们这边打算拿 5W LED 灯珠 + 透镜 + 窄带滤光片，反正又不是成像，能用就行，中间还需要加一片二向色镜滤掉 LED 反射信号，保留荧光信号分给 PDPhoton Detector。第一版原型已经验证了可行性，只不过信号强度比较有限，希望还能提升一点。 按我的初中光学水平，聚焦嘛，几组透镜焦点对上就行。同时尽量缩短光传播的距离减少衰减。所以就需要焦距极短的透镜，聚光能力更强。不过我们仪器体积有限，上不了太大的镜片，只能用鼓形透镜，我们需求的型号又没有现货，第一版跟厂家定制把球形透镜削成鼓形，价格也是非常美丽。 领导提出让我试一下不严格对齐焦点，优先压缩衰减距离，3D 打印个模型试试看效果。同时因为不聚焦了嘛，平凸透镜换更便宜的非球面透镜，滤光片也换了国产供应商进一步压缩成本。SolidWorks 走起。利用 SW 的型腔功能，可以先画镜片的装配，再从一个基体里把镜片的部分切掉。改模型的过程中还发现上一版光路中心偏移了 0.5mm LOL. 因为探头尺寸小了好多，LED 电路板也得重新画，咱也不会 AD，就由另一个学 EE 的实习生照我新画的尺寸再出一版。别说，画板子门道还挺多。这 LED 有发热问题只能用铝基板，铝基板布线只能走单面，LED 功率比较大线宽又不能给太小，但因为压缩了尺寸，紧挨着 LED 的两排 M2 螺丝孔直接断绝了走线的可能。但 3D 打印件已经投出去了，只能填上一排螺丝孔走线。哎，这种活还是得既懂机械又懂电子的人来啊！ 用电源夹着测了下光功率，各通道比上一版提升 50%-100% 不等。 ","date":"2021-12-28","objectID":"/zh-cn/my-first-intern/:3:0","tags":["Rust","C/C++","RTOS","SolidWorks","PCB","Embedded"],"title":"第一份实习","uri":"/zh-cn/my-first-intern/"},{"categories":["work"],"content":"荧光模块采集程序 拿电源测还不够，终究得上我们自己的采集电路试试。探头阵列装在一块 LED 板上，另一个平面再固定一块 PD 板，两块板在交叉处留焊盘再焊上。因为探头阵列整体尺寸变了，不仅 LED 板，PD 板也要重画。PD 嘉立创不给焊而且单独在一面，只能自己用焊膏拿风枪从另一面吹，所以全部件都得手焊，因为体积极小选的封装也超小，焊起来是既费手又费眼睛。因为要尽量减少漏光，3D 打印外壳给 PD 留的定位公差比较小，真正吹 PD 的时候才知道手焊这种贴片元件定位准有多难…… 那个实习生那边焊着板子，我这边准备研究一下采集电路单片机的程序。因为采集电路有好几级放大，为了方便开发做了模块化设计，有单片机在的那块主控板可以通用，留了几路 SPI 从 FPC 排线接出来。但是板子打少了没有空的给我用，只好给了我一个更早的引脚不同的版本，而且同事居然把这版程序搞丢了…… 好在原理图还在，也不是不能重新写，只是之前只会 Arduino AVR 树莓派那些，STM32 还是第一次接触…… 简单看了看，有什么寄存器版，标准库版，HAL 版，看着就头大。电子工程师同事跟着正点原子学下来的。该说不说教程是挺详细，不过时间紧任务重，学到 SPI 那边怎么也得两三周。STM32 这方面。正好入职之前在看 Rust，听说嵌入式也能用，查了一下 STM32F103 的支持也不错，那为啥不试一下呢。直接 quick-start 走起。改下编译配置，瞬间就出来一个 semihosting 打印 helloworld。再从 f1xx-hal example 里抄个点灯，前后也就十来分钟。一看 SPI 也有例程可抄，不过得先研究一下我们 ADC 和 DAC 的手册。 好家伙，前后一共没用了一天半，我这个采集测试程序直接能跑了，震惊同事一整天。Rust 在包管理这块真是吊打 c 语言生态啊。除了打印还是 semihosting 没换成串口，有阻塞和速度问题比较烦人。 ","date":"2021-12-28","objectID":"/zh-cn/my-first-intern/:4:0","tags":["Rust","C/C++","RTOS","SolidWorks","PCB","Embedded"],"title":"第一份实习","uri":"/zh-cn/my-first-intern/"},{"categories":["work"],"content":"荧光采集模块主控固件 紧接着决定整合另外一块板的功能，两个单片机变一个，电机和荧光一起控制，芯片也重新选了 F407，所以程序自然也得重新开始。单位有原子的 407 开发板，还是一样 cargo 导入 hal，点灯一气呵成。因为需要串口通信，还有实时性要求，又研究了下串口中断。一中断就打破了正常的控制流，随之带来潜在的并发问题。又因为 Rust 主打的线程安全，写中断要来回包好几层，一个变量光类型就恨不得半个窗口宽，实在有点丑陋，所以调研了几个 rust RTOS，结果没一个能用的。最后退而求其次选择了 rtic 1.0 了好耶！。但测试了一下串口响应发现比 uC/OS 慢不少，加上调步进电机的 CAN 控制器又遇到了些问题，还有我走了之后 Rust 代码无人维护等等缺陷，最后还是花了大半个月学 uC/OS 和 STM32 hal 库。这段时间真是进步飞快，每天全身心地投在学习里，uC/OS 英文文档来回读了好几遍，结合原子/野火各方例程边学边实践，信号量、队列、内存管理等等概念虽然不能说理解了底层原理，但基本的使用还是不成问题的，还仔细学习了一下上下文切换的核心汇编代码。 整理了一下业务逻辑，仿照内核搞了个任务分发器。串口中断处理完，先进任务分发器，根据消息决定要安排的任务和优先级（不一定回到被打断的任务）。同时还搞了个低优先级的串口发送任务用于回复上位机。我觉得逻辑还蛮清楚的，可同事说这样适合任务复杂的场景，我们这块用不到，却也没说具体怎么调整…… 因为花了很多时间学习，真正业务代码开发就变得非常紧张，加上电机 CAN 驱动器居然有 BUG，停止状态位居然有可能不准，需要额外的定时任务轮询电机状态…… 连续加班半个月我就是个月薪 3000 的实习生啊喂终于赶出了个可用的版本，然后发烧病了三天。等我下周再看到同事改过的代码后，我算是理解了所谓“不用这么复杂”的意思： 跳过分发器任务间直接通信，优先级逻辑要在代码里到处跳才能搞明白 重复逻辑直接复制粘贴绝不循环：8 个信号量 8 个任务 8 个队列，串口任务里 8 个 switch case。反正业务定死了就这么多绝不写成数组 行吧，反正他改过了，那就算他接手了，领导给我派别的任务了 ","date":"2021-12-28","objectID":"/zh-cn/my-first-intern/:5:0","tags":["Rust","C/C++","RTOS","SolidWorks","PCB","Embedded"],"title":"第一份实习","uri":"/zh-cn/my-first-intern/"},{"categories":["work"],"content":"C++/Qt 数据拟合 + 可视化 别说，PCR S 形扩增曲线这个事儿我高中还是学过的。反倒是同事们都是 90 年左右出生，高中的时候 PCR 还没进课本，入职培训听的一愣一愣的。软工同事 GitHub 找了个 GSL 库曲线拟合的 C++ wrapper GPL 代码真的合适么，虽然初始猜测给的很离谱，但双曲正切还是拟出来了而且效果不错。 核酸检测结果需要计算 CTCycle Threshold 值，我们希望软件能够自动计算。流程大概是先拟合，然后定基线范围，按基线平均值 + k 倍基线标准差画一根水平线，取该线和曲线交点 x 值作为 CT 值。基本原理并不难，但实际应用时有各种问题。 拟合异常： 至少开发阶段，不扩增的情况很常见，甚至有时候曲线还能往下掉，这时候拟合就会很离谱。用拟合前一个预判断 + 拟合后参数校验即可 各通道基线对齐： 这个其实好说，拟出来参数之后重新算下 y 偏移就行 通道串扰： 这个比较复杂，需求临近实习结束才提出来，所以我只给出了线代的公式和实现的想法。理论上各通道都是线性的，可以提前用已知强度的荧光溶液标定出各通道的补偿矩阵，实际数据扣除基线后用逆矩阵转换一下即可。如果拟合成功，只需要对各通道的拟合参数应用该矩阵即可。 C++ Qt 虽然也是第一次接触，不过也就掉了一次内存泄漏和一次 std::array 的坑。此外画图的部分沿用了之前同事找的开源控件，还做了一些小小的魔改来适配我们的项目。C++ 业务逻辑写多了，才能体会到 Rust Enum 的设计精妙之处。比方说拟合失败，Rust 里面返回 Result\u003cT,E\u003e 或者 Option\u003cT\u003e 就很符合语义。但在 C++ 里想做到同样的事情就得要么手动实现 tagged union，要么传指向堆内存的可空指针给调用者检查，要么就得用异常。Tagged Union 得给同事们讲明白，传指针项目里从来没这么用过，搞不好又是内存泄漏，试了一下异常结果 Linux 工控机上怎么调编译选项也不支持。还好结果都是 float，只好传进引用然后用 NAN 表示失败了…… ","date":"2021-12-28","objectID":"/zh-cn/my-first-intern/:6:0","tags":["Rust","C/C++","RTOS","SolidWorks","PCB","Embedded"],"title":"第一份实习","uri":"/zh-cn/my-first-intern/"},{"categories":["work"],"content":"总结 虽然说是托关系找的实习，但也确实投入了相当多的实际开发，获得了很多机电软方面的实践经验。第一份实习竟然就得到了如此全面的锻炼！工作环境也相当不错，标配人体工学椅，小零食饮料以及咖啡机，采购报销虽然要自己垫钱但回款也很及时，同事领导也都很友善。 ","date":"2021-12-28","objectID":"/zh-cn/my-first-intern/:7:0","tags":["Rust","C/C++","RTOS","SolidWorks","PCB","Embedded"],"title":"第一份实习","uri":"/zh-cn/my-first-intern/"},{"categories":["tech"],"content":"这段时间在实习和个人项目中学习 STM32 上嵌入式 Rust 的一些总结 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:0:0","tags":["Rust","Embedded"],"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"资料 The Book: 熟悉 Rust 语法，其中并发部分的 channel 和 Mutex, Cell, RefCell 等，在嵌入式中有类似的用法 Discovery: 写博客时发现这本书有了使用 micro:bit 的新版, 我读的是使用 STM32F3Discovery 的旧版 The Embedded Rust Book: 有嵌入式开发经验可以跳过 discovery 直接看这本。我买了 F3 板子所以直接跑在板子上没有用 QEMU RTIC: 一个裸机多任务框架，更好地共享 Rust 变量。我看的时候是 v0.5，现在已经出到 1.0 了，可喜可贺。 ferrous-systems’s blog: 这家公司的博客介绍了许多 Rust 在嵌入式开发中的技巧，获益匪浅。尤其是实现了一个 async/await executor ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:1:0","tags":["Rust","Embedded"],"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"环境搭建 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:2:0","tags":["Rust","Embedded"],"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"Rust 工具链 这里使用 rustup 安装了 msvc 工具链的 rust 按需下载对应平台的 core，否则无法编译： rustup target add thumbv6m-none-eabi # Cortex-M0 and Cortex-M0+ rustup target add thumbv7m-none-eabi # Cortex-M3 rustup target add thumbv7em-none-eabi # Cortex-M4 and Cortex-M7 (no FPU) rustup target add thumbv7em-none-eabihf # Cortex-M4F and Cortex-M7F (with FPU) ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:2:1","tags":["Rust","Embedded"],"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"调试工具 我使用包管理器 scoop, 以下工具scoop install 即可 arm-none-eabi-gdb openocd 此外，如果使用 ST-LINK，需要手动安装驱动 这篇文章末尾提供了使用 vscode 调试的方法，我觉得 gdb 命令行就够用了，因此没有尝试 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:2:2","tags":["Rust","Embedded"],"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"Hello World 仅限 cortex-m 内核，其他平台未研究 cargo generate --git https://github.com/rust-embedded/cortex-m-quickstart 修改 .cargo/config.toml 修改 memory.x 一般 STM32 FLASH 起始地址在 0x08000000, RAM 在 0x20000000. 芯片手册里如果有多段 RAM，取第一段的大小 修改 openocd.cfg，可用的配置文件可以在 openocd 的安装目录下找到 在项目目录下执行openocd, 不要关闭这个终端 另起一个终端，执行cargo run, 观察是否收到输出 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:3:0","tags":["Rust","Embedded"],"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"PAC \u0026 HAL PACPeripheral Access Crate 一般由 svd2rust 根据 ARM 厂商提供的 SVDCMSIS System View Description 文件自动生成，提供了寄存器操作的基本包装，API 用法如： pwm.ctl.modify(|r, w| w.globalsync0().clear_bit()); HALHardware Abstract Layer 在 PAC 基础上遵循 embedded-hal 编写。但至少 STM32 各系列的实现略有区别，导致同样的外设在 f1, f4 系列上的代码可能大不一样，各芯片的 driver crate 也不一定都能使用。部分外设如 FSMC，因为 hal 没有编写相关部分，几乎只能靠手动配置寄存器并引入 unsafe 块才能使用 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:4:0","tags":["Rust","Embedded"],"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"起手式 (裸机) #![no_main] /* main 使用 entry 宏引入 */ #![no_std] /* 不使用 std 因为不可用 */ use panic_semihosting as _; /* 选择 panic 处理方式，不接调试器 semihosting 会卡死 */ // use panic_halt as _; // use panic_abort as _; /* 需要 nightly 工具链 */ // use cortex_m::asm; /* 如果需要直接使用汇编指令 */ use cortex_m_rt::entry; // use cortex_m_semihosting::hprintln; /* semihosting 下的 println！宏，方便调试 */ // use core::fmt::Write; /* 如果使用串口调试，使用 write！宏向串口 tx 输出 */ use hal::{ delay::Delay, /* 常用的延时 */ pac, /* hal 包装过的 pac */ prelude::*, }; use stm32f1xx_hal as hal; /* 导入一个 hal */ #[entry] fn main() -\u003e ! { let (dp, cp) = ( /* dp:device peripherals，指 MCU 厂商扩展的外设 */ pac::Peripherals::take().unwrap(), /* cp: core peripherals，指 ARM 自带的外设 */ cortex_m::Peripherals::take().unwrap(), ); /* 配置时钟 */ let (mut flash, mut rcc) = (dp.FLASH.constrain(), dp.RCC.constrain()); let clocks = rcc.cfgr.use_hse(8.mhz()).freeze(\u0026mut flash.acr); /* 初始化 delay 对象，这里用系统时钟 SYST */ let mut delay = Delay::new(cp.SYST, clocks); /* gpio 抽象，各 hal 略有不同 */ let (mut gpioa, mut gpiob) = (dp.GPIOA.split(\u0026mut rcc.apb2), dp.GPIOB.split(\u0026mut rcc.apb2)); loop{ /* do something */ } } ``` ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:5:0","tags":["Rust","Embedded"],"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"safe 全局变量 我们都知道操作 static mut 是 unsafe 的，大量的编程规范要求尽量减少使用全局变量。但嵌入式环境下往往无法避免。一个更好的方法是规划好变量的作用范围后使用 RTIC. 不过这里先讲一下简单的做法和原理 Atomic 是平台支持下最优雅的做法，简洁，安全。缺点是不能进行有复杂逻辑的操作，且仅支持几种基本数据类型，不过一般需求下够用了。 Mutex\u003cRefCell\u003cT\u003e\u003e 配合临界区使用。需要use cortex_m::interrupt::{self, Mutex};. 可以包装更复杂的数据类型，包括外设。但会引入大量语法噪音。使用方法大致为： 声明一个 static FOO:Mutex\u003cRefCell\u003cOption\u003cT\u003e\u003e\u003e = Mutex::new(RefCell::new(None)); 在 main 中初始化外设并在临界区中使用 interrupt::free(|cs| FOO.borrow(cs).replace(Some(T))); 移动所有权给全局变量 FOO 使用时同样需要进入临界区后，使用 FOO.borrow(cs).borrow() 获取RefCell后再 as_ref() 才能得到内部的 T 我几乎从不使用这种方法，心累手也累，复杂项目直接上 RTIC 完事儿 这部分相当让人抓狂，许多在 C 语言中可以直接写的部分要包上好多层，即便我知道它是安全的。 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:6:0","tags":["Rust","Embedded"],"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"RTIC 我很想管 RTIC 叫抢占式调度框架，如果搭配内存分配器，用起来和抢占式的 RTOS 没啥区别。然而它其实只是个前后台系统，靠设置中断优先级来管理任务，并不具有上下文切换的能力。用它的原因就在于它包装了上述复杂的 Mutex\u003cRefCell\u003cOption\u003cT\u003e\u003e\u003e, 并可以将空闲的硬中断注册为可以有参数和容量的多个软中断。 然而，缺点来自于它使用了大量的宏，导致无论 RLSRust Language Server 还是 RARust Analyzer 都不能很好的支持自动补全和类型。有些报错会一直显示却不影响正常编译… 真正编不过时又找不到报错的原因。因此我经常先在裸机上搭好一些外设驱动框架，调试好类型后再复制进 RTIC 项目。 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:7:0","tags":["Rust","Embedded"],"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"内存分配器 alloc-cortex-m: 需要 nightly 工具链，用法 使用内存分配器后，可以像有 std 一样使用方便地使用 vec! 等。可以先通过 FSMC 配置好外部 RAM 后将其内存起始地址指向 RAM ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:8:0","tags":["Rust","Embedded"],"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"RTOS 我尝试过drone, WSL 和 Linux 物理机都试过，然而连 hello world 都没能跑起来… 它似乎也没在更新了 另外还有Tock OS, 但外设驱动需要自行编写，官方的 ST demo 只有 f3disco 和两个 f4nucleo，并没有尝试过 RTOS 方面估计很难超越 μCOS 和 FreeRTOS，大量芯片驱动都有现成的 C 代码，Rust 这边还只能用爱发电. OS 能否和现有的 hal 框架兼容还是个问题 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:9:0","tags":["Rust","Embedded"],"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"常用 crate heapless: 提供了静态内存分配的常用数据类型 HistoryBuffer: 可用于平滑滤波 spsc::Queue: 消息队列 String: 方便输出调试信息 bitbang-hal: 提供了软件模拟的 I2C, USART, SPI nb: 虽然名字叫做 non-block 但更多用 block！宏来等待外设工作完成，例如： block!(Serial.write(byte))?; micromath: 提供了嵌入式环境下可能缺失的某些 F32 操作 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:10:0","tags":["Rust","Embedded"],"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["tech"],"content":"总结 个人项目的话，Embedded Rust 只能说差强人意。小芯片 debug 编译二进制太大，没法调试。语法噪音也是相当烦人。我利用几个芯片的 crate 写了个平衡车玩，过段时间会专门介绍 实习中用 rust 写了一些小板子的验证 demo，逻辑简单的话用 hal 分分钟就能起个项目。也用 RTIC 尝试过复杂项目，有这么几个问题： 本质仍然是前后台，复杂任务调度比较烧脑 运行速度比 μCOSⅢ 慢不少，写了个简单的串口环回，能慢将近一半。或许是我时钟没配好…也可能人家商业公司在关中断这块儿确实优化的好。尝试了两天，还是改用 μCOS 了，因为即便我这个实习生写出来也以后没人接手维护… Rust 合理的 trait 抽象加上 embedded-hal 这套统一的规范，使得各种库的编写成为可能。我的平衡车项目几乎纯靠调库就能完成，可见这套抽象的威力。这也是 STM32 的标准库和 HAL 库 之所以火遍中国。然而现实很骨感，一是性能损失，这种抽象多少会带来一些冗余代码，当然 LLVM 能不能优化我就不懂了; 二是虽然有 embedded-hal 规定了一些 trait，但 trait 之外的部分各不相同，就比如 ST 系列，FSMC 几乎没有，F1XXHAL 和 F4XXHAL 许多 api 完全不同… 最后一点纯属猜测，C++ 也有虚函数，也完全可以定义一套接口规范，为何 ARM 厂商不用 C++ 呢？虚表实现有性能损失，那编译器也可以用其他实现呀，反正芯片厂的编译器都是魔改过的…这么多年 C++ 都没在嵌入式铺开，Rust 只能说悬 Rust 是个好语言，但在嵌入式方面生态似乎是更主要的问题。没有解决大痛点的话业界根本没有动力抛弃多年积累重新开始。 ","date":"2021-12-27","objectID":"/zh-cn/hello-embedded-rust/:11:0","tags":["Rust","Embedded"],"title":"初探 STM32 嵌入式 Rust","uri":"/zh-cn/hello-embedded-rust/"},{"categories":["misc"],"content":"记录一下我的博客历程 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:0:0","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Notion 搞一个博客的想法由来已久，2017 年接触到 notion，文章可以开启外链，当博客用完全没问题。然而国内访问不稳定，以及——不好看，于是迟迟没有动手。目前主要把 notion 的 database 作为跨平台收藏夹、偶尔写一些较重的 todo list 便于跨平台访问。 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:1:0","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Pelican 2019 年大一期间找点事做，接触到 Github Pages 与静态博客工具，因为相对熟悉 Python 选择了 Pelican。断断续续开发到 2020 年暑假结束，接触了很多前端知识。最后的效果差强人意，虽然确实部署了一两篇文章，但总因为外观不舒心而没有动力更新。在此期间了解了 Hexo Next1, Hugo Meme2 等等基于其他博客平台的主题，确定了自己期望的几个主要功能： dark mode：以前常驻深色模式，但宿舍采光很好，导致白天只能调高亮度用白色模式，夜晚只能调低亮度用深色模式，否则眼睛难受。我的博客自然也应具备这个功能。实现上就是用 js 做两套 css 的切换。具体到深色模式的配色设计，又有很多细节，以及 svg 的适配等等，也是个小坑。 responsive：适配移动端，本质上是 css 的 media 属性。折叠菜单等又需要 js 配合。 toctable of contents：Meme2 可以说满足 99% 的需求，除了没有侧边目录，导致只能线性阅读。更适合杂文而非技术类博客。 一个好看的顶栏，起码 sticky 定位 $\\LaTeX$：KaTeX 或 MathJax markdown 扩展语法 中文：一个好看的中文字体，Meme2 所用的 思源宋体Noto Serif SC 真是太棒了 图片：支持图片下方标注，合理的缩放 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:2:0","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Hugo ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:3:0","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Meme2 如同上文所述，尝试拼一个侧边目录进去，技术力不够调不好看，作罢。 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:3:1","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"Eureka 这个主题的 doc 模式启发了另一种组织文章的方式。 ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:3:2","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"},{"categories":["misc"],"content":"LoveIt 相当惊艳的主题，功能丰富，完成度高。看到之后别无所求了。然而似乎没有再更新了，有意向转向 DoIt，不过先把 LoveIt 折腾明白吧。 https://github.com/iissnan/hexo-theme-next ↩︎ https://io-oi.me 他的文章也很有意思 ↩︎ ↩︎ ↩︎ ↩︎ ","date":"2021-11-08","objectID":"/zh-cn/hello-world/:3:3","tags":null,"title":"你好 世界","uri":"/zh-cn/hello-world/"}]